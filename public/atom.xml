<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Spaghetti Optimization]]></title>
  <link href="http://stegua.github.io/atom.xml" rel="self"/>
  <link href="http://stegua.github.io/"/>
  <updated>2019-01-27T13:48:14+01:00</updated>
  <id>http://stegua.github.io/</id>
  <author>
    <name><![CDATA[Stefano Gualandi]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[An informal and biased Tutorial on Kantorovich-Wasserstein distances]]></title>
    <link href="http://stegua.github.io/blog/2018/12/31/wasserstein-distances-an-operations-research-perspective/"/>
    <updated>2018-12-31T13:13:00+01:00</updated>
    <id>http://stegua.github.io/blog/2018/12/31/wasserstein-distances-an-operations-research-perspective</id>
    <content type="html"><![CDATA[<p>Two years ago, I started to study <strong>Computational Optimal Transport (OT)</strong>, and, now, it is time to wrap up informally the main ideas by using an <em>Operations Research (OR)</em> perspective with a <em>Machine Learning (ML)</em> motivation.</p>

<p>Yes, an <a href="https://twitter.com/hashtag/orms">OR</a> perspective.</p>

<blockquote>
  <p>Why an OR perspective?</p>
</blockquote>

<p>Well, because most of the current theoretical works on Optimal Transport have a strong functional analysis bias, and, hence, the are pretty far to be an “easy reading” for anyone working on a different research area. Since I’m more comfortable with “summations” than with “integrations”, in this post I focus only on Discrete Optimal Transport and on Kantorovich-Wasserstein distances between a pair of discrete measure.</p>

<blockquote>
  <p>Why an <a href="https://nips.cc/Conferences/2017/Schedule?showEvent=8758">ML</a> motivation?</p>
</blockquote>

<p>Because measuring the <strong>similarity</strong> between complex objects is a crucial basic step in several <a href="https://twitter.com/hashtag/machinelearning?vertical=news&amp;src=hash">#machinelearning</a> tasks. Mathematically, in order to measure the similarity (or dissimilarity) between two objects we need a metric, i.e., a distance function. And <em>Optimal Transport</em> gives us a powerful similarity measure based on the solution of a <strong>Combinatorial Optimization</strong> problem, which can be formulated and solved with <strong>Linear Programming</strong>.</p>

<p><strong>The main Inspirations for this post are:</strong></p>

<p><em>. My current favorite tutorial is <a href="https://arxiv.org/abs/1801.07745">Optimal Transport on Discrete Domains</a>, by <a href="http://people.csail.mit.edu/jsolomon/">Justin Solomon</a>.
*. Two years ago, I started to study this topic thanks to <a href="https://www-dimat.unipv.it/savare/">Giuseppe Savaré</a>, and I wrote this post by looking also to <a href="https://www-dimat.unipv.it/savare/Ravello2010/ravelloB.pdf">his set of slides</a>. He has several interesting papers and you can look at his <a href="https://www-dimat.unipv.it/savare/pubblicazioni/all.html">publications list</a>.
*. For a complete overview of this topic look at the <a href="https://optimaltransport.github.io/book/">Computational Optimal Transport</a> book, by <a href="http://www.gpeyre.com/">Gabriel Peyré</a> and <a href="http://marcocuturi.net/">Marco Cuturi</a>. These two researchers, together with Justin Solomon, where among the organizers of two <a href="https://en.wikipedia.org/wiki/Conference_on_Neural_Information_Processing_Systems">#NeurIPS</a> workshops, in <a href="http://www.iip.ist.i.kyoto-u.ac.jp/OTML2014/doku.php?id=home">2014</a> and in <a href="http://otml17.marcocuturi.net/">2017</a>, on *Optimal Transport and Machine Learning</em>.
*. For a broader history of Combinatorial Optimization till 1960, see <a href="https://homepages.cwi.nl/~lex/files/histco.pdf">this manuscript by Alexander Schrijver</a>.</p>

<p><strong>DISCLAIMER 1:</strong> This is a long “ongoing” post, and, despite my efforts, it might contain errors of any type. If you have any suggestion for improving this post, please (!), let me know about: I will be more than happy to mention you (or any of your avatars) in the acknowledgement section. Otherwise, if you prefer, I can offer you a drink, whenever we will meet in real life.</p>

<p><strong>DISCLAIMER 2:</strong> I wrote this post while reading the book <strong><a href="https://www.goodreads.com/book/show/9969571-ready-player-one">Ready Player One</a></strong>, by Ernest Cline.</p>

<p><strong>DISCLAIMER 3:</strong> I’m recruiting postdocs. If you like the topic of this post and you are looking for a postdoc position, write me an email.</p>

<h2 id="similarity-measures-and-distance-functions">Similarity measures and distance functions</h2>
<p>A <strong>metric</strong> is a function, usually denoted by <script type="math/tex">d</script>, between a pair of objects belonging to a space <script type="math/tex">X</script>:</p>

<script type="math/tex; mode=display">d : X \times X \rightarrow \mathbb{R}_+</script>

<p>Given any triple of points <script type="math/tex">x,y,z \in X</script>, the conditions that <script type="math/tex">d</script> must satisfy in order to be a metric are:</p>

<ol>
  <li><script type="math/tex">d(x,y) \geq 0</script> <em>(non negativity)</em></li>
  <li><script type="math/tex">d(x,y) = 0 \Leftrightarrow x=y</script> <em>(identity of indiscernibles)</em></li>
  <li><script type="math/tex">d(x,y) = d(y,x)</script> <em>(symmetry)</em></li>
  <li><script type="math/tex">d(x,z) \leq d(x,y) + d(y,z)</script> <em>(triangle inequality or subadditivity)</em></li>
</ol>

<p>If the space <script type="math/tex">X</script> is <script type="math/tex">\mathbb{R}^k</script>, then <script type="math/tex">\mathbf{x}, \mathbf{y}, \mathbf{z}</script> are vectors of <script type="math/tex">k</script> elements, and the most common distance is indeed the Euclidean function</p>

<script type="math/tex; mode=display">d(\mathbf{x},\mathbf{y}) = \sqrt{\sum_{i = 1}^k(x_i - y_i)^2}</script>

<p>where <script type="math/tex">x_i</script> is the <script type="math/tex">i</script>-th component of the vector <script type="math/tex">\mathbf{x}</script>. Clearly, the algorithmic complexity of computing (in finite precision) this distance is linear with the dimension of <script type="math/tex">X</script>.</p>

<p><strong>QUESTION:</strong> What if we want to compute the distance between a pair of clouds of <script type="math/tex">n</script> points defined in <script type="math/tex">\mathbb{R}^k</script>?</p>

<p>If we want to compute the distance between the two vectors, that represent the two clouds of <script type="math/tex">n</script> points, we need to define a distance function.</p>

<p>Let me fix the notation first. If <script type="math/tex">\mathbf{x}</script> is a vector, then <script type="math/tex">x_i</script> is the <script type="math/tex">i</script>-th element. Suppose we have two matrices <script type="math/tex">\mathbf{X}</script> and <script type="math/tex">\mathbf{Y}</script> with <script type="math/tex">n \times k</script> elements, which represent <script type="math/tex">n</script> points in <script type="math/tex">\mathbb{R}^k</script>. We denote by <script type="math/tex">\mathbf{x}_i</script> the <script type="math/tex">i</script>-th row of matrix <script type="math/tex">\mathbf{X}</script>, and by <script type="math/tex">x_{ij}</script> the <script type="math/tex">j</script>-th element of row <script type="math/tex">i</script>. Indeed, the rows <script type="math/tex">\mathbf{x}_i</script> and <script type="math/tex">\mathbf{y}_i</script> of the two matrices give the coordinates <script type="math/tex">x_{i1},\dots,x_{ik}</script> and <script type="math/tex">y_{i1},\dots,y_{ik}</script> of the two corresponding points.</p>

<p>Whenever <script type="math/tex">k=1</script>, a simple choice is to consider the <a href="https://en.wikipedia.org/wiki/Minkowski_distance">Minkowski Distance</a>, which is a metric for normed vector spaces:</p>

<script type="math/tex; mode=display">M_p(\mathbf{x},\mathbf{y}) = \left( \sum_{i=1}^n \mid x_i - y_i\mid^p \right)^{\frac{1}{p}}</script>

<p>where typical values of <script type="math/tex">p</script> are:</p>

<ul>
  <li><script type="math/tex">p=1</script> (Manhattan distance)</li>
  <li><script type="math/tex">p=2</script> (Euclidean distance, see above)</li>
  <li><script type="math/tex">p=\infty</script> (Infinity distance)</li>
</ul>

<p>We have also the Minkowski norm, that is a function</p>

<script type="math/tex; mode=display">\ell_p : \mathbb{R} \rightarrow \mathbb{R}_+</script>

<p>computed as</p>

<script type="math/tex; mode=display">\ell_p(\mathbf{x}) = \left( \sum_{i=1}^n \mid x_i \mid^p\right)^{\frac{1}{p}}</script>

<p>Whenever <script type="math/tex">k>1</script>, we have to consider a more general distance function:</p>

<script type="math/tex; mode=display">D : \mathbb{R}^{n \times k} \times \mathbb{R}^{n \times k} \rightarrow \mathbb{R}_+</script>

<p>such that the relations (1)-(4) are satisfied. We could use as distance function <script type="math/tex">D(\mathbf{X},\mathbf{Y})</script> any <a href="https://en.wikipedia.org/wiki/Matrix_norm">matrix norm</a>, but, to begin with, we can use the Minkowski distance twice in cascade as follows.</p>

<ol>
  <li>First, we compute the distance between a pair of points in <script type="math/tex">\mathbb{R}^k</script>, which we call the <strong>ground distance</strong>, using <script type="math/tex">M_q</script>, with <script type="math/tex">q\geq 1</script>. By applying this function to all the <script type="math/tex">n</script> pairs of points, we get a vector <script type="math/tex">\mathbf{z}</script> of <script type="math/tex">n</script> non-negative values:</li>
</ol>

<script type="math/tex; mode=display"> z_i = M_q(\mathbf{x}_i,\mathbf{y}_i), \quad i=1,\dots, n</script>

<ol>
  <li>Second, we apply the Minkowski norm <script type="math/tex">\ell_p</script> to the vector <script type="math/tex">\mathbf{z}</script>.</li>
</ol>

<p>Composing these two operations, we can define a distance function between a pair of vectors of points (i.e., pair of matrices) as follows:</p>

<script type="math/tex; mode=display">% &lt;![CDATA[
D_{p,q}(\mathbf{X},\mathbf{Y}) = \ell_p(\mathbf{z}) = \ell_p(\left< M_q(\mathbf{x}_i,\mathbf{y}_i)\right>) = \left( \sum_{i=1}^n \left( \sum_{j = 1}^n \left(x_{ij} - y_{ij}\right)^q  \right)^{\frac{p}{q}} \right)^{\frac{1}{p}} %]]&gt;</script>

<p>Note that for <script type="math/tex">p=q=2</script>, we get</p>

<script type="math/tex; mode=display">D_{2,2}(\mathbf{X},\mathbf{Y}) = \sqrt{\sum_{i=1}^n \sum_{j = 1}^n \left(x_{ij} - y_{ij}\right)^2} = \mid\mid \mathbf{X} - \mathbf{Y}\mid\mid_F</script>

<p>which is the <a href="https://en.wikipedia.org/wiki/Matrix_norm#Frobenius_norm">Frobenius Norm</a> of the element wise difference <script type="math/tex">\mathbf{X} - \mathbf{Y}</script>.</p>

<p>The main drawback of this distance function is that it implicitly relies on the order (position) of the single points in the two input vectors: any permutation of one (or both) of the two vectors will yield a different value of the ground distance. This happens because the distance function between the two input vectors considers only “interactions” between the <script type="math/tex">i</script>-th pair of points stored at the same <script type="math/tex">i</script>-th position in the two vectors.</p>

<p><strong>IMPORTANT.</strong> Here is where Discrete Optimal Transport comes into action: it offers an alternative distance function based on the solution of a <strong>Combinatorial Optimization</strong> problem, which is, in the simplest case, formulated as the following <strong>Linear Program</strong>:</p>

<script type="math/tex; mode=display">% &lt;![CDATA[
\begin{aligned}\mathcal{W}_d(\mathbf{X},\mathbf{Y}) := \min \;\;& \sum_{i=1}^n\sum_{j=1}^n d(\mathbf{x}_i,\mathbf{y}_j) \pi_{ij} \\
 & \sum_{i=1}^n \pi_{ij} = 1& j=1,\dots,n \\
 & \sum_{j=1}^n \pi_{ij} = 1& i=1,\dots,n \\
 & \pi_{ij} \geq 0 & i=1,\dots,n, j=1,\dots,n .
 \end{aligned} %]]&gt;</script>

<p>If you have a minimal <a href="https://twitter.com/hashtag/orms">#orms</a> background at this point you should have recognized that this problem is a standard <a href="https://en.wikipedia.org/wiki/Assignment_problem">Assignment Problem</a>: we have to assign each point of the first vector <script type="math/tex">\mathbf{x}</script> to a single point of the second vector <script type="math/tex">\mathbf{y}</script>, in such a way that the overall cost is minimum. From an optimal solution of this problem, we can select among all possible permutations of the rows of <script type="math/tex">\mathbf{Y}</script>, the permutation that gives the minimal value of the Frobenius norm.</p>

<p>Whenever the ground distance <script type="math/tex">d(\mathbf{x},\mathbf{y})</script> is a metric, then <script type="math/tex">\mathcal{W}_d(\mathbf{X},\mathbf{Y})</script> is a metric as well. In other terms, the optimal value of this problem is a measure of distance between the two vectors, while the optimal values of the decision variables <script type="math/tex">\mathbf{\pi}</script> gives a mapping from the rows of <script type="math/tex">\mathbf{X}</script> to the rows of <script type="math/tex">\mathbf{Y}</script> (in OT terminology, an <em>optimal plan</em>). This is possible because the LP problem has a <a href="https://en.wikipedia.org/wiki/Unimodular_matrix">Totally Unimodular</a> coefficient matrix, and, hence, every basic optimal solution of the LP problem has integer values.</p>

<blockquote>
  <p><strong>WAIT, LET ME STOP HERE FOR A SECOND!</strong></p>
</blockquote>

<p>I am being too technical, too early. Let me take a step back in <em>History</em>.</p>

<h2 id="once-upon-a-time-from-monge-to-kantorovich">Once Upon a Time: from Monge to Kantorovich</h2>
<p>The History of Optimal Transport is quite fascinating and it begins with the <a href="https://gallica.bnf.fr/ark:/12148/bpt6k35800/f796"><em>Mémoire sur la théorie des déblais et des remblais</em></a> by <a href="https://en.wikipedia.org/wiki/Gaspard_Monge">Gaspard Monge</a> (1746-1818). I like to think of Gaspard as visiting the <a href="https://en.wikipedia.org/wiki/Dune_of_Pilat">Dune of Pilat</a>, near Bordeaux, and then writing his <em>Mémoire</em> while going back to home… but this is only my imagination. Still, particles of sand give me the most concrete idea for passing from a continuous to a discrete problem.</p>

<p><img class="center" src="../../../../../../images/dune_pillat.JPG" /></p>

<p>In his <em>Mémoire</em>, Gaspard Monge considered the problem of transporting <em>“des terres d’un lieu dans un autre”</em> at minimal cost. The idea is that we have first to consider the cost of transporting a single molecule of <em>“terre”</em>, which is proportional to its weight and to the distance from its initial and final position. The total cost of transportation is given by summing up the transportation cost of each single molecule. Using the Lex Schrijver’s words, Monge’s transportation problem was <a href="https://homepages.cwi.nl/~lex/files/histco.pdf">camouflaged as a continuous problem</a>.</p>

<p>The idea of Gaspard is to assign to each initial position a single final destination: it is not possible to split a molecule into smaller parts. This unsplittable version of the problem posed a very challenging problem where <a href="https://math.berkeley.edu/~evans/Monge-Kantorovich.survey.pdf"><em>“the direct methods of the calculus of variations fail spectacularly”</em></a> (<a href="https://math.berkeley.edu/~evans/">Lawrence C. Evans</a>, see link at page 5). This challenge stayed unsolved until the work of <a href="https://en.wikipedia.org/wiki/Leonid_Kantorovich">Leonid Kantorovich</a> (1912-1986).</p>

<p>Curiously, Leonid did not arrive to the transportation problem while studying directly the work of Monge. Instead, he was asked to solve an industrial resource allocation problem, which is more general than Monge’s problem. Only a few years later, he reconsidered his contribution in terms of the continuous probabilistic version of Monge’s transportation problem. However, I am unable to state the true technical contributions of Leonid with respect to the work of Gaspard in a short post (well, honestly, I would be unable even in an infinite post), but I recommend you to read the <a href="https://link.springer.com/article/10.1007%2Fs00283-013-9380-x">Long History of the Monge-Kantorovich Transportation Problem</a>.</p>

<p>Anyway, I have pretty clear the two main concepts that are the foundations of the work by Kantorovich:</p>

<ol>
  <li><strong>RELAXATION</strong>: He relaxes the problem posed by Gaspard and he proves that an optimal solution of the relaxation equals an optimal solution of the original problem (Here is the link to the very unofficial soundtrack of his work: <a href="https://www.youtube.com/watch?v=RVmG_d3HKBA">“Relax, take it easy!”</a>). Indeed, Leonid relaxed formulation allows each molecule to be split across several destinations, differently from the formulation of Monge. In OR terms, he solves a Hitchcock Problem, not an Assignment Problem. For more details, see Chapter 1 of the <a href="https://optimaltransport.github.io/book/">Computational Optimal Transport</a>.</li>
</ol>

<p><img class="center" src="../../../../../../images/relax_easy.PNG" /></p>

<ol>
  <li><strong>DUALITY</strong>: Leonid uses a dual formulation of the relaxed problem. Indeed, he <em>invented</em> the dual potential functions and he sketched the first version of dual simplex algorithm. Unfortunately, I studied Linear Programming duality without having an historical perspective, and hence duality looks like <em>obvious</em>, but at the time is was clearly a new concept.</li>
</ol>

<p>For the records, Leonid Kantorovich won the Nobel Prize, and <a href="https://www.nobelprize.org/prizes/economic-sciences/1975/kantorovich/25950-autobiography-1975/">his autobiography</a> merits to be read more than once.</p>

<p>Well, I have still so much to learn from the past!</p>

<h3 id="two-fields-medal-winners-alessio-figalli-and-cedric-villani">Two Fields medal winners: Alessio Figalli and Cedric Villani</h3>
<p>If you think that Optimal Transport belongs to the past, you are wrong!</p>

<p>Last summer (2018), in Rio de Janeiro, <a href="https://people.math.ethz.ch/~afigalli/">Alessio Figalli</a> won the <a href="https://en.wikipedia.org/wiki/Fields_Medal">Fields Medal</a> with this citation:</p>

<blockquote>
  <p><em>“for his contributions to the <strong>theory of optimal transport</strong>, and its application to partial differential equations, metric geometry, and probability”</em></p>
</blockquote>

<p>Alessio is not the first Fields medalist who worked on Optimal Transport. Already <a href="https://cedricvillani.org/for-mathematicians/">Cedric Villani</a>, who wrote the <a href="http://cedricvillani.org/wp-content/uploads/2012/08/B07.StFlour.pdf">most cited book</a> on Optimal Transport [1], won the Fields Medal in 2010. I strongly suggest you to look any of <a href="https://www.youtube.com/watch?v=Kc0Kthyo0hU">his lectures available on Youtube</a>. And … do you know that Villani spent a short period of time during his PhD in my current Math Dept. at University of Pavia?</p>

<p>As an extra bonus, if you don’t know what a Fields Medal is, you can have Robin Williams to explain the prize in this clip taken from <a href="https://www.youtube.com/watch?v=TRU4YYxM7vU">Good Will Hunting</a>.</p>

<h2 id="discrete-optimal-transport-and-linear-programming">Discrete Optimal Transport and Linear Programming</h2>
<p>It is time of being technical again and to move from the Monge assignment problem, to the Kantorovich “relaxed” transportation problem. In the assignment model presented above, we are implicitly considering that all the positions are occupied by a single molecule of unitary weight. If we want to consider the more general setting of Discrete Optimal Transport, we need to consider the “mass” of each molecule, and to formulate the problem of transporting the total mass at minimum cost. Before presenting the model, we define formally the concept of a <strong>discrete measure</strong> and of the <strong>cost matrix</strong> between all pairs of molecule positions.</p>

<p><strong>DISCRETE MEASURES:</strong> Given a of vector of <script type="math/tex">n</script> positions <script type="math/tex">\mathbf{x}_i</script>, and given the <a href="https://en.wikipedia.org/wiki/Dirac_delta_function">Dirac delta function</a>, we can define the <em>Dirac measures</em> <script type="math/tex">\delta_{\mathbf{x}_i}</script> as</p>

<script type="math/tex; mode=display">% &lt;![CDATA[
\delta_{\mathbf{x}_i}(A) = \left\{ \begin{array}{ll} 1 & \text{if} \;\;\mathbf{x}_i \in A \subseteq X \\ 0 & \text{if} \;\;\mathbf{x}_i \notin A \subseteq X \\  \end{array}\right. %]]&gt;</script>

<p>Given a vector of <script type="math/tex">n</script> weights <script type="math/tex">\mu_i</script>, one associated to each element of <script type="math/tex">\mathbf{x}</script>, we can define the <strong>discrete measure</strong> <script type="math/tex">\mathbf{\mu}</script> as</p>

<script type="math/tex; mode=display">\mu(A) = \sum_{i=1}^n \mu_i \delta_{\mathbf{x}_i}</script>

<p>Note the <script type="math/tex">\mu</script> is a function of type: <script type="math/tex">\mu : A \rightarrow \mathbb{R}_+</script>, for any subset <script type="math/tex">A</script> of <script type="math/tex">X</script>. The vector <script type="math/tex">\mathbf{x}</script> is called the support of the measure <script type="math/tex">\mathbf{\mu}</script>. In Computer Science terms, <em>a discrete measure is defined by a vector of pairs</em>, where each pair contains a positive number <script type="math/tex">\mu_i</script> (the measured value) and its support point <script type="math/tex">\mathbf{x}_i</script> (the location where the measure occurred). Note that <script type="math/tex">\mathbf{x}_i</script> is a (small?) vector storing the coordinates of the <script type="math/tex">i</script>-th point.</p>

<p><strong>COST MATRIX:</strong> Given two discrete measures <script type="math/tex">\mathbf{\mu}</script> and <script type="math/tex">\mathbf{\nu}</script>, the first with support <script type="math/tex">\mathbf{x}</script> and the second with support <script type="math/tex">\mathbf{y}</script>, we can define the following cost matrix:</p>

<script type="math/tex; mode=display">c_{ij} = d(\mathbf{x}_i, \mathbf{y}_j), \quad \text{for } i=1,\dots,n \text{ and } j= 1,\dots, m</script>

<p>where <script type="math/tex">d</script> is a distance function, such as, for instance, the Minkowski distance <script type="math/tex">M_q(\mathbf{x},\mathbf{y})</script> defined before. Note that <script type="math/tex">\mathbf{\mu}</script> has <script type="math/tex">n</script> elements, and <script type="math/tex">\mathbf{\nu}</script> has <script type="math/tex">m</script> elements.</p>

<h3 id="kantorovich-wasserstein-distances-between-two-discrete-measures">Kantorovich-Wasserstein distances between two discrete measures</h3>
<p>At this point, we have all the basic elements to define the <strong>Kantorovich-Wasserstein distance function between discrete measures</strong> in terms of the solution of a (huge) Linear Program.</p>

<p><strong>INPUT:</strong> Two discrete measures <script type="math/tex">\mathbf{\mu}</script> and <script type="math/tex">\mathbf{\nu}</script> defined on a metric space <script type="math/tex">X</script>, and the corresponding supports <script type="math/tex">\mathbf{x}</script> and <script type="math/tex">\mathbf{y}</script>, having <script type="math/tex">n</script> and <script type="math/tex">m</script> elements, respectively. A distance function <script type="math/tex">d</script>, which permits to compute the cost <script type="math/tex">c_{ij}</script>.</p>

<p><strong>OUTPUT:</strong> A transportation plan <script type="math/tex">\mathbf{\pi}</script> and a value of distance of <script type="math/tex">\mathcal{W}(\mathbf{\mu}, \mathbf{\nu})</script> that corresponds to an optimal solution of the following Linear Program:</p>

<script type="math/tex; mode=display">% &lt;![CDATA[
\begin{aligned}
\mathcal{W}(\mathbf{\mu},\mathbf{\nu}) := \min \;\;& \sum_{i=1}^n\sum_{j=1}^m c_{ij} \pi_{ij} \\
 & \sum_{j=1}^m \pi_{ij} \geq \mu_i & i=1,\dots,n \\
 & \sum_{i=1}^n \pi_{ij} \leq \nu_j& j=1,\dots,m \\
 & \pi_{ij} \geq 0 & i=1,\dots,n, j=1,\dots,m.
 \end{aligned} %]]&gt;</script>

<p>This Linear Program is indeed a special case of the <a href="https://www.jstor.org/stable/2627172?seq=1#page_scan_tab_contents">Transportation Problem</a>, known also as the Hitchcock-Koopmans problem. It is a special case because the cost vector has a strong structure that should be exploited as much as possible.</p>

<p><strong>Computational Challenge:</strong> While the previous problem is polynomially solvable, the size of practical instances is very large. For instance, if you want to compute the distance between a pair of grey scale images of resolution <script type="math/tex">512 \times 512</script> pixels, you end up with an LP with <script type="math/tex">512^4 = 68\;719\;476\;736</script> cost coefficients. Hence, these problems must be handled with care. If you want to see how the solution time and memory requirement scale for grey scale image, please, have a look at the <a href="http://www.iasi.cnr.it/aussois/web/uploads/2018/slides/gualandis.pdf">slides of my talk at Aussois (2018)</a>.</p>

<p><img class="center" src="../../../../../../images/ot_challenge.png" /></p>

<h3 id="kantorovich-wasserstein-distance">KANTOROVICH-WASSERSTEIN DISTANCE</h3>

<p>Whenever</p>

<ol>
  <li>The two measure are discrete probability measures, that is, both <script type="math/tex">\sum_{i=1}^n \mu_i = 1</script> and <script type="math/tex">\sum_{j = 1}^m \nu_j = 1</script> (i.e., <script type="math/tex">\mathbf{\mu}</script> and <script type="math/tex">\mathbf{\nu}</script> belongs to the probability simplex), and,</li>
  <li>The cost vector is defined as the <script type="math/tex">p</script>-th power of a distance,</li>
</ol>

<p>then we define the <strong>Kantorovich-Wasserstein distance of order <script type="math/tex">p</script></strong> as the following functional:</p>

<script type="math/tex; mode=display">\mathcal{W}_p(\mathbf{\mu},\mathbf{\nu}) := \left(\min_{\pi \in U} \sum_{i=1}^n\sum_{j=1}^m d(\mathbf{x}_i, \mathbf{y}_j)^p \pi_{ij} \right)^{\frac{1}{p}}</script>

<p>where the set <script type="math/tex">U</script> is defined as:</p>

<script type="math/tex; mode=display">% &lt;![CDATA[
U := \left\{\begin{array}{ll}
 \sum_{j=1,\dots,m} \pi_{ij} \leq \mu_i & i=1,\dots,n \\
 \sum_{i=1,\dots,n} \pi_{ij} \geq \nu_j& j=1,\dots,m \\
 \pi_{ij} \geq 0 & i=1,\dots,n, j=1,\dots,m. \\
 \end{array}
 \right\}
 %]]&gt;</script>

<p>From a mathematical perspective, the most interesting case is the order <script type="math/tex">p=2</script>, which <em>generalizes</em> the Euclidean distance to discrete probability vectors. Note that in this formulation, the two constraint sets defining <script type="math/tex">U</script> could be replaced with equality constraints, since <script type="math/tex">\mathbf{\mu}</script> and <script type="math/tex">\mathbf{\nu}</script> belongs to the probability simplex. In addition, any Combinatorial Optimization algorithm must be used with care, since all the cost and constraint coefficients are not integer.
<strong>Note:</strong> The <script type="math/tex">p</script> power used for the ground distance must not be confused with the order (power) of a Kantorovich-Wasserstein distance.</p>

<h3 id="earth-mover-distance">EARTH MOVER DISTANCE</h3>

<p>A particular case of the Kantorovich-Wasserstein distance very popular in the Computer Vision research community, is the so-called <strong>Earth Mover Distance (EMD)</strong> [2], which is used between a pair of <script type="math/tex">k</script>-dimensional histograms obtained by preprocessing the images of interest. In this case, (i) we have <script type="math/tex">n=m</script>, (ii) we do not require the discrete measures to belong to the probability simplex, and (iii) we do not even require that the two measures are <em>balanced</em>, that is, <script type="math/tex">\sum_{i=1}^n \mu_i = \sum_{j=1}^n \nu_j</script>. In Optimal Transport terminology, the Earth Mover Distance solves an <strong>unbalanced optimal transport problem</strong>. For the EMD, the feasibility set <script type="math/tex">U</script> is replaced by the set:</p>

<script type="math/tex; mode=display">% &lt;![CDATA[
V := \left\{\begin{array}{ll}
 \sum_{i=1}^n \sum_{j=1}^n \pi_{ij} = \min \{ \sum_{i=1}^n \mu_i, \sum_{j=1}^n \nu_j \}& \\
 \sum_{j=1,\dots,n} \pi_{ij} \geq \mu_i & i=1,\dots,n \\
 \sum_{i=1,\dots,n} \pi_{ij} \geq \nu_j& j=1,\dots,n \\
 \pi_{ij} \geq 0 & i=1,\dots,n, j=1,\dots,n. \\
 \end{array}
 \right\}
 %]]&gt;</script>

<p>The cost function is taken with the order <script type="math/tex">p=1</script>:</p>

<script type="math/tex; mode=display">EMD(\mathbf{x},\mathbf{y}) := \min_{\pi \in V} \sum_{i=1}^n\sum_{j=1}^m d(x_i, y_j) \pi_{ij}</script>

<p>The most used function <script type="math/tex">d</script> is the Minkowski distance induced by the <script type="math/tex">\ell_p</script> norm.</p>

<h3 id="word-mover-distance">WORD MOVER DISTANCE</h3>

<p>A very interesting application of discrete optimal transport is the definition of a metric for text documents [3]. The main idea is, first, to exploit a <a href="https://en.wikipedia.org/wiki/Word_embedding">word embedding</a> obtained, for instance, with the popular <a href="https://www.tensorflow.org/tutorials/representation/word2vec">word2vec</a> neural network [4], and, second, to formulate the problem of “transporting” a text document into another at minimal cost.</p>

<blockquote>
  <p>Yes, but … how we compute the ground distance between two words?</p>
</blockquote>

<p>A word embedding associates to each word of a given vocabulary a vector of <script type="math/tex">\mathbb{R}^k</script>. For the pre-trained embedding made available by Google at <a href="https://code.google.com/archive/p/word2vec/">this archive</a>, which contains the embedding of around 3 millions of words, <script type="math/tex">k</script> is equals to 300. Indeed, given a vocabulary of <script type="math/tex">n</script> words and fixed a dimension <script type="math/tex">k</script>, a word embedding is given by a matrix <script type="math/tex">\mathbf{X}</script> of dimension <script type="math/tex">n \times k</script>: Row <script type="math/tex">\mathbf{x}_i</script> gives the <script type="math/tex">k</script>-dimensional vector representing the word embedding of word <script type="math/tex">i</script>.</p>

<p>In this case, instead of having discrete measures, we deal with normalized bag-of-words (nBOW), which are vector of <script type="math/tex">\mathbb{R}^n</script>, where <script type="math/tex">n</script> denotes the number of words in the vocabulary. If a text document <script type="math/tex">\mathbf{\mu} \in \mathbb{R}^n</script> contains <script type="math/tex">t_i</script> times the word <script type="math/tex">i</script>, then <script type="math/tex">\mathbf{\mu}_i = \frac{t_i}{\sum_{j=1}^n t_j}</script>. At this point is clear that the <strong>ground distance</strong> between a pair of words is given by the distance between the corresponding embedding vectors in <script type="math/tex">\mathbb{R}^k</script>, that is, given two words <script type="math/tex">i</script> and <script type="math/tex">j</script>, then</p>

<script type="math/tex; mode=display">c(i,j) = \ell_2(\mathbf{x}_i - \mathbf{x}_j)</script>

<p>Finally, given two text documents <script type="math/tex">\mathbf{\mu}</script> and <script type="math/tex">\mathbf{\nu}</script>, we can formulate the Linear Program that gives the <strong>Word Mover Distance</strong> as:</p>

<script type="math/tex; mode=display">\text{WMD}(\mathbf{\mu},\mathbf{\nu}) := \min_{\pi \in U} \sum_{i=1}^n\sum_{j=1}^n c(\mathbf{x}_i, \mathbf{x}_j) \pi_{ij}</script>

<p>where the set <script type="math/tex">U</script> is defined as:</p>

<script type="math/tex; mode=display">% &lt;![CDATA[
U := \left\{\begin{array}{ll}
 \sum_{j=1,\dots,n} \pi_{ij} = \mu_i & i=1,\dots,n \\
 \sum_{i=1,\dots,n} \pi_{ij} = \nu_j& j=1,\dots,n \\
 \pi_{ij} \geq 0 & i=1,\dots,n, j=1,\dots,n. \\
 \end{array}
 \right\}
 %]]&gt;</script>

<p>If you are serious reader, and you are still reading this post, then it is clear that the Word Mover Distance is exactly a Kantorovich-Wasserstein distance of order 1, with an Euclidean ground distance. If you are interested in the quality of this distance when used within a nearest neighbor heuristic for a text classification task, we refer to [3]. <em>(While writing this post, I started to wonder how would perform a <strong>WMD</strong> of order 2, but this is another story…)</em></p>

<h3 id="interesting-research-directions">Interesting Research Directions</h3>
<p>The following are the research topics I am interested in right now. Each topic deserves its own blog post, but let me write here just a short sketch.</p>

<ul>
  <li>
    <p><strong>Computational Challenges:</strong> The development of efficient algorithms for the solution of Optimal Transport problems is an active area of research. Currently, the preferred (heuristic) approach is based on so-called <a href="http://marcocuturi.net/SI.html">regularized optimal transport</a>, introduced originally in [5]. Indeed, regularized optimal transport deserves its own blog post.
In two recent works, together with my co-authors, we tried to revive the <a href="https://scholar.google.it/scholar?q=dantzig+network+simplex&amp;hl=en&amp;as_sdt=0&amp;as_vis=1&amp;oi=scholart">Network Simplex</a> for two special cases: Kantorovich-Wasserstein distances of order 1 for <script type="math/tex">k</script>-dimensional histograms [6] and Kantorovich-Wasserstein distances of order 2 for decomposable cost functions [7]. The second paper  was presented as a <a href="https://github.com/stegua/dpartion-nips2018/blob/master/poster/PosterNIPS2018.pdf">poster at NeurIPS2018</a>. <em>(If you ever read any of the two papers, please, let me know what you think about them)</em></p>
  </li>
  <li>
    <p><strong>Unbalanced Optimal Transport:</strong> The computation of Kantorovich-Wasserstein distance for pair of unbalanced discrete measures is very challenging. Last year, a brilliant math student finished a nice project on this topic, which I hope to finalize during the next semester.</p>
  </li>
  <li>
    <p><strong>Barycenters of Discrete Measures:</strong> The Kantorovich-Wasserstein distance can be used to generalize the concept of <em>barycenters</em>, that is, the problem of finding a discrete measure that is the closest (in Kantorovich terms) to a given set of discrete measures. The problem of finding the barycenter can be formulated as a Linear Program, where the unknowns (the decision variables) are both the transport plan and the discrete measure representing the barycenter. For instance, the following images, taken from our last draft paper, represents the barycenters of each of the 10 digits of the <a href="http://yann.lecun.com/exdb/mnist/">MNIST</a> data set of handwritten images (each image is the barycenter of other <script type="math/tex">3\;200</script> images).</p>
  </li>
</ul>

<p><img class="center" src="../../../../../../images/mnist_bary.PNG" /></p>

<ul>
  <li><strong>Distances between Discrete Measures defined on different metric spaces:</strong> This topic is at the top of my 2019 resolutions. There are a few papers by <a href="https://people.math.osu.edu/memoli.2/">Facundo Mémoli</a> on this topic, which are based on the so-called <strong>Gromov-Wasserstein distance</strong> and that requires the solution of a <strong>Quadratic Assignment Problem (QAP)</strong>.</li>
</ul>

<p>Now, it’s time to close this post with final remarks.</p>

<h2 id="optimal-transport-a-brilliant-future">Optimal Transport: A brilliant future?</h2>
<p>Given the number and the quality of results achieved on the Theory of Optimal Transport by “pure” mathematicians, it is the time to turn these theoretical results into a set of useful algorithms implemented in efficient and scalable solvers. So far, the only public library I am aware of is <a href="https://github.com/rflamary/POT">POT: Python Optimal Transport</a>.</p>

<p>On <a href="https://medium.com/">Medium</a>, C.E. Perez claims that <a href="https://medium.com/intuitionmachine/optimal-transport-theory-the-new-math-for-deep-learning-2520395fc183">Optimal Transport Theory (is) the New Math for Deep Learning</a>. In his short post, he explains how Optimal Transport is used in Deep Learning algorithms, specifically in <strong>Generative Adversarial Networks (GANs)</strong>, to replace the <strong>Kullback-Leibler (KL) divergence</strong>.</p>

<p>Honestly, I do not have a clear idea regarding the potential impact of Kantorovich distances on <strong>GANs</strong> and <strong>Deep Learning</strong> in general, but I think there are a lot of research opportunities for everyone with a strong passion for <strong>Computational Combinatorial Optimization</strong>.</p>

<p>And you, what do you think about the topics presented in this post?</p>

<p>As usual, I will be very happy to hear from you, in the meantime…</p>

<blockquote>
  <p><strong>GAME OVER</strong></p>
</blockquote>

<h3 id="acknowledgement">Acknowledgement</h3>
<p>I would like to thank <a href="https://imada.sdu.dk/~marco/">Marco Chiarandini</a>, <a href="https://www.southampton.ac.uk/maths/about/staff/sc2r15.page">Stefano Coniglio</a>, and <a href="http://www-dimat.unipv.it/~bassetti/">Federico Bassetti</a> for constructive criticism of this blog post.</p>

<h3 id="references">References</h3>

<ol>
  <li>
    <p>Villani, C. <span class="title">Optimal transport, old and new.</span> Grundlehren der mathematischen Wissenschaften, Vol.338, Springer-Verlag, 2009. <a href="http://cedricvillani.org/wp-content/uploads/2012/08/B07.StFlour.pdf">[pdf]</a></p>
  </li>
  <li>
    <p>Rubner, Y., Tomasi, C. and Guibas, L.J., 2000. <span class="title">The earth mover&#8217;s distance as a metric for image retrieval.</span> International journal of computer vision, 40(2), pp.99-121. <a href="https://idp.springer.com/authorize/casa?redirect_uri=https://link.springer.com/content/pdf/10.1023/A:1026543900054.pdf&amp;casa_token=Ysv8VHVK29EAAAAA:nIcUgwC_iwnFqj7C1DUcKcVi-JY4FvCt9GQOhNQsa4nmVe_H3BfpO197Y_sakGDwqCfziSHEt3q1Mg">[pdf]</a></p>
  </li>
  <li>
    <p>Kusner, M.J., Sun, Y., Kolkin, N.I., Weinberger, K.Q. <span class="title">From Word Embeddings To Document Distances.</span> Proceedings of the 32 nd International Conference on Machine Learning, Lille, France, 2015. <a href="http://proceedings.mlr.press/v37/kusnerb15.pdf">[pdf]</a></p>
  </li>
  <li>
    <p>Mikolov, T., Sutskever, I., Chen, K., Corrado, G.S. and Dean, J., 2013. <span class="title">Distributed representations of words and phrases and their compositionality.</span> In Advances in neural information processing systems (pp. 3111-3119). <a href="https://papers.nips.cc/paper/5021-distributed-representations-of-words-and-phrases-and-their-compositionality.pdf">[pdf]</a></p>
  </li>
  <li>
    <p>Cuturi, M., 2013. <span class="title">Sinkhorn distances: Lightspeed computation of optimal transport.</span> In Advances in neural information processing systems (pp. 2292-2300). <a href="https://papers.nips.cc/paper/4927-sinkhorn-distances-lightspeed-computation-of-optimal-transport.pdf">[pdf]</a></p>
  </li>
  <li>
    <p>Bassetti, F., Gualandi, S. and Veneroni, M., 2018. <span class="title">On the Computation of Kantorovich-Wasserstein Distances between 2D-Histograms by Uncapacitated Minimum Cost Flows.</span> arXiv preprint arXiv:1804.00445. <a href="https://arxiv.org/pdf/1804.00445">[pdf]</a></p>
  </li>
  <li>
    <p>Auricchio, G., Bassetti, F., Gualandi, S. and Veneroni, M., 2018. <span class="title">Computing Kantorovich-Wasserstein Distances on d-dimensional histograms using (d+1)-partite graphs. </span> NeurIPS, 2018.<a href="https://arxiv.org/pdf/1805.07416">[pdf]</a></p>
  </li>
</ol>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Exercise in Python: remove blanks from strings]]></title>
    <link href="http://stegua.github.io/blog/2017/01/24/exercise-in-python-remove-blanks-from-strings/"/>
    <updated>2017-01-24T16:51:00+01:00</updated>
    <id>http://stegua.github.io/blog/2017/01/24/exercise-in-python-remove-blanks-from-strings</id>
    <content type="html"><![CDATA[<p>This morning, after reading <a href="http://lemire.me/blog/2017/01/20/how-quickly-can-you-remove-spaces-from-a-string/">this very nice post</a>, I decided to challenge myself in Python and to have a look at the impact of <a href="https://en.wikipedia.org/wiki/Branch_misprediction">mispredicted branches</a> in a language different from C/C++. The basic idea was to use only <a href="https://docs.python.org/3.6/library/functions.html">Python builtins</a>: external libraries are not allowed!</p>

<p>As a benchmark, I grabbed a large text file from <a href="http://norvig.com/big.txt">P. Norvig’s website</a>, which is 6’488’666 byte long.</p>

<p><strong>The final answer?</strong> Yes, <strong>mispredicted branches</strong> have a huge impact in Python too.</p>

<p><strong>The hidden answer?</strong> Python dictionaries ever stop to surprise me: they are REALLY efficient.</p>

<p><strong>NOTE</strong>: The followig code snippets were executed in a Python 3.5 notebook, on a windows machine, running Windows 10 and <a href="https://www.continuum.io/downloads">Anaconda Python 3.5 64 bits</a>.
You can find my notebook on my <a href="https://github.com/stegua/MyBlogEntries">Blog GitHub repo</a>. Don’t ask me why, but this blog entry is better visualized directly on <a href="https://github.com/stegua/MyBlogEntries/blob/master/Remove%2Bblanks%2Bfrom%2Ba%2Bstring.ipynb">GitHub</a>.</p>

<p><strong>UPDATE</strong>: Well, most of the time I would use my first implementation based on the <code>filter</code> builtin function, and I would try for alternative implementations only after a profiler has shown
that removing blanks is a true bottleneck of my whole program. As written in the title, this post is meant as a basic exercise in Python.</p>

<h3 id="first-attempt-functional-style">First attempt: Functional style</h3>
<p>In Python, I prefer to write as much code in functional style as possible, relying on the 3 basic functions:</p>

<ol>
  <li><a href="https://docs.python.org/3/library/functions.html#map"><code>map</code></a></li>
  <li><a href="https://docs.python.org/3/library/functions.html#filter"><code>filter</code></a></li>
  <li><a href="https://docs.python.org/3/library/functools.html#functools.reduce"><code>reduce</code></a> (this is in the functools module and it is not a true builtin)</li>
</ol>

<p>Therefore, after few preliminaries, here is my first code snippet:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
</pre></td><td class="code"><pre><code class="python"><span class="line"><span></span><span class="kn">import</span> <span class="nn">cProfile</span>
</span><span class="line">
</span><span class="line"><span class="c1"># Download file from: &#39;http://norvig.com/big.txt&#39;</span>
</span><span class="line"><span class="n">big</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;big.txt&#39;</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span>
</span><span class="line">
</span><span class="line"><span class="c1"># Read the while file</span>
</span><span class="line"><span class="n">test</span> <span class="o">=</span> <span class="n">big</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
</span><span class="line">
</span><span class="line"><span class="k">def</span> <span class="nf">RemoveBlanksFilter</span><span class="p">(</span><span class="n">in_str</span><span class="p">):</span>
</span><span class="line">    <span class="n">result</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">c</span><span class="p">:</span> <span class="n">c</span> <span class="o">!=</span> <span class="s1">&#39;</span><span class="se">\r</span><span class="s1">&#39;</span> <span class="ow">and</span> <span class="n">c</span> <span class="o">!=</span> <span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span> <span class="ow">and</span> <span class="n">c</span> <span class="o">!=</span> <span class="s1">&#39; &#39;</span><span class="p">,</span> <span class="n">in_str</span><span class="p">)</span>
</span><span class="line">    <span class="k">return</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
</span><span class="line">
</span><span class="line"><span class="n">test_result</span> <span class="o">=</span> <span class="n">RemoveBlanksFilter</span><span class="p">(</span><span class="n">test</span><span class="p">)</span>
</span><span class="line">
</span><span class="line"><span class="n">cProfile</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="s1">&#39;RemoveBlanksFilter(test)&#39;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<pre><code>         6488671 function calls in 1.956 seconds

   Ordered by: standard name

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
        1    0.000    0.000    1.955    1.955 &lt;ipython-input-3-eeb7d3495697&gt;:1(RemoveBlanksFilter)
  6488666    0.870    0.000    0.870    0.000 &lt;ipython-input-3-eeb7d3495697&gt;:2(&lt;lambda&gt;)
        1    0.000    0.000    1.956    1.956 &lt;string&gt;:1(&lt;module&gt;)
        1    0.000    0.000    1.956    1.956 {built-in method builtins.exec}
        1    0.000    0.000    0.000    0.000 {method 'disable' of '_lsprof.Profiler' objects}
        1    1.085    1.085    1.955    1.955 {method 'join' of 'str' objects}
</code></pre>

<p>Wow, I didn’t realize that I would have call the lambda function for every single byte of my input file. This is clearly too much overhead.</p>

<h3 id="nd-attempt-remove-function-calls-overhead">2nd attempt: remove function calls overhead</h3>
<p>Let me drop my functional style, and write a plain old for-loop:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class="python"><span class="line"><span></span><span class="k">def</span> <span class="nf">RemoveBlanks</span><span class="p">(</span><span class="n">in_str</span><span class="p">):</span>
</span><span class="line">    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
</span><span class="line">    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">in_str</span><span class="p">:</span>
</span><span class="line">        <span class="k">if</span> <span class="n">c</span> <span class="o">!=</span> <span class="s1">&#39;</span><span class="se">\r</span><span class="s1">&#39;</span> <span class="ow">and</span> <span class="n">c</span> <span class="o">!=</span> <span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span> <span class="ow">and</span> <span class="n">c</span> <span class="o">!=</span> <span class="s1">&#39; &#39;</span><span class="p">:</span>
</span><span class="line">            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
</span><span class="line">    <span class="k">return</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
</span><span class="line">
</span><span class="line"><span class="k">print</span><span class="p">(</span><span class="s1">&#39;Is test passed:&#39;</span><span class="p">,</span> <span class="n">test_result</span> <span class="o">==</span> <span class="n">RemoveBlanks</span><span class="p">(</span><span class="n">test</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<pre><code>Is test passed: True
</code></pre>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="python"><span class="line"><span></span><span class="n">cProfile</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="s1">&#39;RemoveBlanks(test)&#39;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<pre><code>         5452148 function calls in 1.566 seconds

   Ordered by: standard name

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
        1    1.210    1.210    1.553    1.553 &lt;ipython-input-6-5e45e3056bc2&gt;:1(RemoveBlanks)
        1    0.012    0.012    1.566    1.566 &lt;string&gt;:1(&lt;module&gt;)
        1    0.000    0.000    1.566    1.566 {built-in method builtins.exec}
  5452143    0.310    0.000    0.310    0.000 {method 'append' of 'list' objects}
        1    0.000    0.000    0.000    0.000 {method 'disable' of '_lsprof.Profiler' objects}
        1    0.033    0.033    0.033    0.033 {method 'join' of 'str' objects}
</code></pre>

<p>Mmm… we just shift the problem to the list append function calls. Maybe we can do better by working in place.</p>

<h3 id="rd-attempt-work-in-place">3rd attempt: work in place</h3>
<p>Well, almost in place: Python string are immutable; therefore, we first copy the string into a list, and then we work in place over the copied list.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
</pre></td><td class="code"><pre><code class="python"><span class="line"><span></span><span class="k">def</span> <span class="nf">RemoveBlanksInPlace</span><span class="p">(</span><span class="n">in_str</span><span class="p">):</span>
</span><span class="line">    <span class="nb">buffer</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">in_str</span><span class="p">)</span>
</span><span class="line">    <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span>
</span><span class="line">    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">in_str</span><span class="p">:</span>
</span><span class="line">        <span class="k">if</span> <span class="n">c</span> <span class="o">!=</span> <span class="s1">&#39;</span><span class="se">\r</span><span class="s1">&#39;</span> <span class="ow">and</span> <span class="n">c</span> <span class="o">!=</span> <span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span> <span class="ow">and</span> <span class="n">c</span> <span class="o">!=</span> <span class="s1">&#39; &#39;</span><span class="p">:</span>
</span><span class="line">            <span class="nb">buffer</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span>
</span><span class="line">            <span class="n">pos</span> <span class="o">+=</span> <span class="mi">1</span>
</span><span class="line">    <span class="k">return</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">buffer</span><span class="p">[:</span><span class="n">pos</span><span class="p">])</span>
</span><span class="line">
</span><span class="line"><span class="k">print</span><span class="p">(</span><span class="s1">&#39;Is test passed:&#39;</span><span class="p">,</span> <span class="n">test_result</span> <span class="o">==</span> <span class="n">RemoveBlanksInPlace</span><span class="p">(</span><span class="n">test</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<pre><code>Is test passed: True
</code></pre>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="python"><span class="line"><span></span><span class="n">cProfile</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="s1">&#39;RemoveBlanksInPlace(test)&#39;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<pre><code>         5 function calls in 1.158 seconds

   Ordered by: standard name

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
        1    1.113    1.113    1.145    1.145 &lt;ipython-input-9-99d36ae6359e&gt;:1(RemoveBlanksInPlace)
        1    0.013    0.013    1.158    1.158 &lt;string&gt;:1(&lt;module&gt;)
        1    0.000    0.000    1.158    1.158 {built-in method builtins.exec}
        1    0.000    0.000    0.000    0.000 {method 'disable' of '_lsprof.Profiler' objects}
        1    0.032    0.032    0.032    0.032 {method 'join' of 'str' objects}
</code></pre>

<p>Ok, working in place does have an impact. Let me go on the true point: avoiding <em>mispredicted branches</em>.</p>

<h3 id="th-attempt-to-avoid-mispredicted-branches">4th attempt: to avoid mispredicted branches</h3>
<p>As in the <a href="http://lemire.me/blog/2017/01/20/how-quickly-can-you-remove-spaces-from-a-string/">original blog post</a>:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
</pre></td><td class="code"><pre><code class="python"><span class="line"><span></span><span class="k">def</span> <span class="nf">RemoveBlanksNoBranch</span><span class="p">(</span><span class="n">in_str</span><span class="p">):</span>
</span><span class="line">    <span class="c1"># Build table</span>
</span><span class="line">    <span class="n">table</span> <span class="o">=</span> <span class="p">[]</span>
</span><span class="line">    <span class="k">for</span> <span class="n">ic</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">256</span><span class="p">):</span>
</span><span class="line">        <span class="n">c</span> <span class="o">=</span> <span class="nb">chr</span><span class="p">(</span><span class="n">ic</span><span class="p">)</span>
</span><span class="line">        <span class="k">if</span> <span class="n">c</span> <span class="o">==</span> <span class="s1">&#39;</span><span class="se">\r</span><span class="s1">&#39;</span> <span class="ow">or</span> <span class="n">c</span> <span class="o">==</span> <span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span> <span class="ow">or</span> <span class="n">c</span> <span class="o">==</span> <span class="s1">&#39; &#39;</span><span class="p">:</span>
</span><span class="line">            <span class="n">table</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</span><span class="line">        <span class="k">else</span><span class="p">:</span>
</span><span class="line">            <span class="n">table</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span><span class="line">
</span><span class="line">    <span class="c1"># Removal</span>
</span><span class="line">    <span class="nb">buffer</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">in_str</span><span class="p">)</span>
</span><span class="line">    <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span>
</span><span class="line">    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">in_str</span><span class="p">:</span>
</span><span class="line">        <span class="nb">buffer</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span>
</span><span class="line">        <span class="n">pos</span> <span class="o">+=</span> <span class="n">table</span><span class="p">[</span><span class="nb">ord</span><span class="p">(</span><span class="n">c</span><span class="p">)]</span>  <span class="c1"># ord() is a function --&gt; bottleneck</span>
</span><span class="line">    <span class="k">return</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">buffer</span><span class="p">[:</span><span class="n">pos</span><span class="p">])</span>
</span><span class="line">
</span><span class="line">
</span><span class="line"><span class="k">print</span><span class="p">(</span><span class="s1">&#39;Is test passed:&#39;</span><span class="p">,</span> <span class="n">test_result</span> <span class="o">==</span> <span class="n">RemoveBlanksNoBranch</span><span class="p">(</span><span class="n">test</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<pre><code>Is test passed: True
</code></pre>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="python"><span class="line"><span></span><span class="n">cProfile</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="s1">&#39;RemoveBlanksNoBranch(test)&#39;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<pre><code>         6489183 function calls in 1.474 seconds

   Ordered by: standard name

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
        1    1.235    1.235    1.460    1.460 &lt;ipython-input-12-1bd75a3de21d&gt;:1(RemoveBlanksNoBranch)
        1    0.014    0.014    1.474    1.474 &lt;string&gt;:1(&lt;module&gt;)
      256    0.000    0.000    0.000    0.000 {built-in method builtins.chr}
        1    0.000    0.000    1.474    1.474 {built-in method builtins.exec}
  6488666    0.192    0.000    0.192    0.000 {built-in method builtins.ord}
      256    0.000    0.000    0.000    0.000 {method 'append' of 'list' objects}
        1    0.000    0.000    0.000    0.000 {method 'disable' of '_lsprof.Profiler' objects}
        1    0.033    0.033    0.033    0.033 {method 'join' of 'str' objects}
</code></pre>

<p>Ouch!!! These are getting even worse! Why? Well, ‘ord’ is a function, so we are getting back the overhead of function calls. Can we do better by using a dictionary instead of an array?</p>

<h3 id="th-attempt-use-a-dictionary">5th attempt: use a dictionary</h3>
<p>Let me use a dictionary in order to avoid the ‘ord’ function calls.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
</pre></td><td class="code"><pre><code class="python"><span class="line"><span></span><span class="k">def</span> <span class="nf">RemoveBlanksNoBranchDict</span><span class="p">(</span><span class="n">in_str</span><span class="p">):</span>
</span><span class="line">    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">in_str</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">str</span><span class="p">:</span>
</span><span class="line">        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;This function works only for strings&#39;</span><span class="p">)</span>
</span><span class="line">
</span><span class="line">    <span class="c1"># Build table</span>
</span><span class="line">    <span class="n">table</span> <span class="o">=</span> <span class="p">{}</span>
</span><span class="line">    <span class="k">for</span> <span class="n">ic</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">256</span><span class="p">):</span>
</span><span class="line">        <span class="n">c</span> <span class="o">=</span> <span class="nb">chr</span><span class="p">(</span><span class="n">ic</span><span class="p">)</span>
</span><span class="line">        <span class="k">if</span> <span class="n">c</span> <span class="o">==</span> <span class="s1">&#39;</span><span class="se">\r</span><span class="s1">&#39;</span> <span class="ow">or</span> <span class="n">c</span> <span class="o">==</span> <span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span> <span class="ow">or</span> <span class="n">c</span> <span class="o">==</span> <span class="s1">&#39; &#39;</span><span class="p">:</span>
</span><span class="line">            <span class="n">table</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
</span><span class="line">        <span class="k">else</span><span class="p">:</span>
</span><span class="line">            <span class="n">table</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
</span><span class="line">
</span><span class="line">    <span class="c1"># Removal</span>
</span><span class="line">    <span class="nb">buffer</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">in_str</span><span class="p">)</span>
</span><span class="line">    <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span>
</span><span class="line">    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">in_str</span><span class="p">:</span>
</span><span class="line">        <span class="nb">buffer</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span>
</span><span class="line">        <span class="n">pos</span> <span class="o">+=</span> <span class="n">table</span><span class="p">[</span><span class="n">c</span><span class="p">]</span>
</span><span class="line">    <span class="k">return</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">buffer</span><span class="p">[:</span><span class="n">pos</span><span class="p">])</span>
</span><span class="line">
</span><span class="line">
</span><span class="line"><span class="k">print</span><span class="p">(</span><span class="s1">&#39;Is test passed:&#39;</span><span class="p">,</span> <span class="n">test_result</span> <span class="o">==</span> <span class="n">RemoveBlanksNoBranchDict</span><span class="p">(</span><span class="n">test</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<pre><code>Is test passed: True
</code></pre>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="python"><span class="line"><span></span><span class="n">cProfile</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="s1">&#39;RemoveBlanksNoBranchDict(test)&#39;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<pre><code>         261 function calls in 0.771 seconds

   Ordered by: standard name

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
        1    0.724    0.724    0.758    0.758 &lt;ipython-input-15-46ad4c3f0b26&gt;:1(RemoveBlanksNoBranchDict)
        1    0.013    0.013    0.771    0.771 &lt;string&gt;:1(&lt;module&gt;)
      256    0.000    0.000    0.000    0.000 {built-in method builtins.chr}
        1    0.000    0.000    0.771    0.771 {built-in method builtins.exec}
        1    0.000    0.000    0.000    0.000 {method 'disable' of '_lsprof.Profiler' objects}
        1    0.034    0.034    0.034    0.034 {method 'join' of 'str' objects}
</code></pre>

<p>Oooh, yes! Now we can see that without <strong>mispredicted branches</strong> we can really speed up our algorithm.</p>

<p>Is this the best pythonic solution? No, surely not, but still it is an interesting remark to keep in mind when coding.</p>

<h3 id="final-remark-a-simple-pythonic-solution">Final remark: a simple pythonic solution</h3>
<p>Likely, the simplest pythonic solution is just to use the ‘replace’ string function as follows:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class="python"><span class="line"><span></span><span class="k">def</span> <span class="nf">RemoveBlanksBuiltin</span><span class="p">(</span><span class="n">in_str</span><span class="p">):</span>
</span><span class="line">    <span class="n">s1</span> <span class="o">=</span> <span class="n">in_str</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\r</span><span class="s1">&#39;</span><span class="p">,</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
</span><span class="line">    <span class="n">s2</span> <span class="o">=</span> <span class="n">s1</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">,</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
</span><span class="line">    <span class="k">return</span> <span class="n">s2</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">,</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
</span><span class="line">
</span><span class="line">
</span><span class="line"><span class="k">print</span><span class="p">(</span><span class="s1">&#39;Is test passed:&#39;</span><span class="p">,</span> <span class="n">test_result</span> <span class="o">==</span> <span class="n">RemoveBlanksBuiltin</span><span class="p">(</span><span class="n">test</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<pre><code>Is test passed: True
</code></pre>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="python"><span class="line"><span></span><span class="n">cProfile</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="s1">&#39;RemoveBlanksBuiltin(test)&#39;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<pre><code>         7 function calls in 0.065 seconds

   Ordered by: standard name

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
        1    0.001    0.001    0.064    0.064 &lt;ipython-input-18-58fd6655cfba&gt;:1(RemoveBlanksBuiltin)
        1    0.001    0.001    0.065    0.065 &lt;string&gt;:1(&lt;module&gt;)
        1    0.000    0.000    0.065    0.065 {built-in method builtins.exec}
        1    0.000    0.000    0.000    0.000 {method 'disable' of '_lsprof.Profiler' objects}
        3    0.063    0.021    0.063    0.021 {method 'replace' of 'str' objects}
</code></pre>

<p>Here we are, the best solution is indeed to use a builtin function, whenever it is possible, even if this was not the real aim of this exercise.</p>

<p>Please, let me know if you have some comments or a different solution in Python.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Graph Coloring: Column Generation or Column Enumeration?]]></title>
    <link href="http://stegua.github.io/blog/2015/07/04/column-enumeration/"/>
    <updated>2015-07-04T16:45:00+02:00</updated>
    <id>http://stegua.github.io/blog/2015/07/04/column-enumeration</id>
    <content type="html"><![CDATA[<style type="text/css">
table { width:100%; }
thead {
   background-color: rgba(0,0,255,0.3);
   color: black;
   text-indent: 14px;
   text-align: left;
}
td { padding:4px; }
tbody tr:nth-child(odd) { background-color: rgba(0, 0, 100, 0.2);  }
tbody tr:nth-child(even) { background-color: rgba(0, 0, 100, 0.1); }
.title { color: #07235F; }
.journal { font-style: italic; }
</style>

<p>In this post, I like to share a simple idea on how to solve to optimality some <a href="http://www.info.univ-angers.fr/pub/porumbel/graphs/">hard instances</a> of the <a href="http://en.wikipedia.org/wiki/Graph_coloring">Graph Coloring</a> problem. This simple idea yields a “new time” record for a couple of hard instances. </p>

<p>To date, the best <strong>exact</strong> approach to solve Graph Coloring 
is based on <em><a href="http://en.wikipedia.org/wiki/Branch_and_price">Branch-and-Price</a></em> [1, 2, 3].
The branch-and-price method is completely different from the Constraint Programming approach I discussed in a <a href="http://stegua.github.io/blog/2013/06/28/gecol/">previous post</a>. A key component of Branch-and-Price is the <em>column generation</em> phase, which is 
intuitively quite simple, but mathematically rather involved for a short blog post.</p>

<p>Here, I want to show you that a modern Mixed Integer Programming (MIP) solver, such as <a href="http://www.gurobi.com/">Gurobi</a> or <a href="http://www-01.ibm.com/software/commerce/optimization/cplex-optimizer/">CPLEX</a>, can solve a few hard instances of graph coloring with the following <em>“null implementation effort”</em>:</p>

<ol>
  <li>Enumerate all possible columns</li>
  <li>Build a <a href="http://en.wikipedia.org/wiki/MPS_%28format%29">.mps</a> instance with those columns</li>
  <li>Use a MIP solver to solve the .mps instance</li>
</ol>

<p>Indeed, in this post we try to answer to the following question:</p>

<blockquote>
  <p>Is there any hope to solve any hard graph coloring instances with this naive approach?</p>
</blockquote>

<h2 id="formulation">Formulation</h2>
<p>Given an undirected graph <script type="math/tex">G=(V,E)</script> and a set of colors <script type="math/tex">K</script>, 
the minimum (vertex) graph coloring problem consists of assigning a color to each vertex,
while every pair of adjacent vertices gets a different color. The objective is to minimize the number of colors used in a solution.</p>

<p>The branch-and-price approach to graph coloring is based on a <em>set covering</em> formulation.
Let <script type="math/tex">S</script> be the collection of all the maximal stable sets of <script type="math/tex">G</script>,
and let <script type="math/tex">S_i \subseteq S</script> be the maximal stable sets that contain the vertex <script type="math/tex">i</script>.
Let <script type="math/tex">\lambda_s</script> be a 0-1 variable equal to 1 if all the vertices in the maximal stable set <script type="math/tex">s \in S</script> 
get assigned the same color. Hence, the set covering model is:</p>

<script type="math/tex; mode=display">\min \sum_{s \in S} \lambda_s \mbox{ such that } \sum_{s \in S_i} \lambda_s \geq 1, \forall i \in N, \lambda_s \in \{0,1\}, \forall s \in S.</script>

<p>Indeed, we <em>“cover”</em> every vertex of <script type="math/tex">G</script> with the minimal number of maximal stable sets.
The issue with this model is the total number of maximal stable sets in <script type="math/tex">G</script>, which <em>is exponential in the number of vertices of G</em>.</p>

<p>Column Generation is a “mathematically elegant” method to by-pass this issue:
it lets you to solve the set covering model by <em>generating</em> a very small subset of the elements in <script type="math/tex">S</script>. This happens by repeatedly solving an auxiliary problem,
called the <em>pricing</em> subproblem. For graph coloring, the pricing subproblem consists of a Maximum Weighted Stable Set problem.
If you are interested in Column Generation, I recommend you to look at the first chapter of
the <a href="http://www.springer.com/gp/book/9780387254852">Column Generation book</a>,
which contains a nice tutorial on the topic, and I would <strong>strongly</strong> recommend reading the nice survey “Selected Topics in Column Generation”, [4].</p>

<blockquote>
  <p>How many maximal stable sets are in a hard graph coloring instance?</p>
</blockquote>

<p>If this number were not so high, we could enumerate all the stable sets in <script type="math/tex">S</script>
and attempt to directly solve the set covering model without resorting to column generation.
However, <em>“high”</em> is a subjective measure, so let me do some computations on my laptop and give you some precise numbers.</p>

<h2 id="hard-instances">Hard instances</h2>
<p>Among the <a href="http://mat.gsia.cmu.edu/COLOR/instances.html">DIMACS instances</a> of Graph Coloring, there are a few instances
proposed by David Johnson, which are still unsolved (in the sense that we have not a computational proof of optimality of the best known upper bounds).</p>

<p>The table below shows the dimensions of these instances. The name of instances are DSJC{n}.{d}, where {n} is the number of vertices and {d} gives the density of the graph (e.g., DSJC125.9 has 125 vertices and 0.9 of density).</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">Graph</th>
      <th style="text-align: center">Nodes</th>
      <th style="text-align: center">Edges</th>
      <th style="text-align: center">Max stable sets</th>
      <th style="text-align: center">Enumeration Time</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">DSJC125.9</td>
      <td style="text-align: center">125</td>
      <td style="text-align: center">6,961</td>
      <td style="text-align: center">524</td>
      <td style="text-align: center">0.00</td>
    </tr>
    <tr>
      <td style="text-align: left">DSJC250.9</td>
      <td style="text-align: center">250</td>
      <td style="text-align: center">27,897</td>
      <td style="text-align: center">2,580</td>
      <td style="text-align: center">0.01</td>
    </tr>
    <tr>
      <td style="text-align: left">DSJC500.9</td>
      <td style="text-align: center">500</td>
      <td style="text-align: center">112,437</td>
      <td style="text-align: center">14,560</td>
      <td style="text-align: center">0.12</td>
    </tr>
    <tr>
      <td style="text-align: left">DSJC1000.9</td>
      <td style="text-align: center">1,000</td>
      <td style="text-align: center">449,449</td>
      <td style="text-align: center">100,389</td>
      <td style="text-align: center">2.20</td>
    </tr>
    <tr>
      <td style="text-align: left">DSJC125.5</td>
      <td style="text-align: center">125</td>
      <td style="text-align: center">3,891</td>
      <td style="text-align: center">43,268</td>
      <td style="text-align: center">0.53</td>
    </tr>
    <tr>
      <td style="text-align: left">DSJC250.5</td>
      <td style="text-align: center">250</td>
      <td style="text-align: center">15,668</td>
      <td style="text-align: center">1,470,363</td>
      <td style="text-align: center">43.16</td>
    </tr>
    <tr>
      <td style="text-align: left">DSJC500.5</td>
      <td style="text-align: center">500</td>
      <td style="text-align: center">62,624</td>
      <td style="text-align: center">?</td>
      <td style="text-align: center">out of memory</td>
    </tr>
    <tr>
      <td style="text-align: left">DSJC1000.5</td>
      <td style="text-align: center">1,000</td>
      <td style="text-align: center">249,826</td>
      <td style="text-align: center">?</td>
      <td style="text-align: center">out of memory</td>
    </tr>
    <tr>
      <td style="text-align: left">DSJC125.1</td>
      <td style="text-align: center">125</td>
      <td style="text-align: center">736</td>
      <td style="text-align: center">?</td>
      <td style="text-align: center">out of memory</td>
    </tr>
    <tr>
      <td style="text-align: left">DSJC250.1</td>
      <td style="text-align: center">250</td>
      <td style="text-align: center">3,218</td>
      <td style="text-align: center">?</td>
      <td style="text-align: center">out of memory</td>
    </tr>
    <tr>
      <td style="text-align: left">DSJC500.1</td>
      <td style="text-align: center">500</td>
      <td style="text-align: center">12,458</td>
      <td style="text-align: center">?</td>
      <td style="text-align: center">out of memory</td>
    </tr>
    <tr>
      <td style="text-align: left">DSJC1000.1</td>
      <td style="text-align: center">1,000</td>
      <td style="text-align: center">49,629</td>
      <td style="text-align: center">?</td>
      <td style="text-align: center">out of memory</td>
    </tr>
  </tbody>
</table>

<p><br />
As you can see the number of maximal stable sets (i.e. the cardinality of <script type="math/tex">S</script>)
of several instances is not so high, above all for very dense graphs, where the number of stables set is less than the number of edges. However, for sparse graphs, the number of maximal stable sets is too large for the memory available in my laptop.</p>

<p>Now, let me re-state the main question of this post:</p>

<blockquote>
  <p>Can we <strong>enumerate</strong> all the maximal stable sets of <script type="math/tex">G</script> and use a  MIP solver such as <a href="http://www.gurobi.com/">Gurobi</a> or <a href="http://www-01.ibm.com/software/commerce/optimization/cplex-optimizer/">CPLEX</a> to solve any Johnson’s instance of Graph Coloring?</p>
</blockquote>

<h2 id="results">Results</h2>
<p>I have written a small script which uses <a href="http://users.aalto.fi/~pat/cliquer.html">Cliquer</a> to enumerate all the maximal
stable sets of a graph, and then I generate an <a href="http://en.wikipedia.org/wiki/MPS_%28format%29">.mps</a>
instance for each of the DSJC instance where I was able to store all maximal stable sets.
The .mps file are on my public <a href="https://github.com/stegua/MyBlogEntries/tree/master/Coloring">GitHub repository for this post</a>.</p>

<p>The table below shows some numbers for the sparse instances obtained using Gurobi (v6.0.0)
with a timeout of 10 minutes on my laptop. If you compare these numbers with the results published in the literature, you can see that they are not bad at all.</p>

<p>Believe me, these number are not bad at all, and establish a new <strong>TIME RECORD</strong>.</p>

<p>For example, the instance DSJC250.9 was solved to optimality only recently in
11094 seconds by [3], while the column enumeration approach solves the same instance on a similar hardware in only 23 seconds (!), and, honestly, our work in [2] did not solve this instance to optimality at all.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">Graph</th>
      <th style="text-align: center">Best known</th>
      <th style="text-align: center">Enum. Time</th>
      <th style="text-align: center">Run time</th>
      <th style="text-align: center">LB</th>
      <th style="text-align: center">UB</th>
      <th style="text-align: center">Time [2]</th>
      <th style="text-align: center">LB[2]</th>
      <th style="text-align: center">UB [2]</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">DSJC125.9</td>
      <td style="text-align: center"><strong>44</strong></td>
      <td style="text-align: center">0.00</td>
      <td style="text-align: center"><strong>0.44</strong></td>
      <td style="text-align: center"><strong>44</strong></td>
      <td style="text-align: center"><strong>44</strong></td>
      <td style="text-align: center">44</td>
      <td style="text-align: center"><strong>44</strong></td>
      <td style="text-align: center"><strong>44</strong></td>
    </tr>
    <tr>
      <td style="text-align: left">DSJC250.9</td>
      <td style="text-align: center"><strong>72</strong></td>
      <td style="text-align: center">0.01</td>
      <td style="text-align: center"><strong>23</strong></td>
      <td style="text-align: center"><strong>72</strong></td>
      <td style="text-align: center"><strong>72</strong></td>
      <td style="text-align: center">timeout</td>
      <td style="text-align: center">71</td>
      <td style="text-align: center">72</td>
    </tr>
    <tr>
      <td style="text-align: left">DSJC500.9</td>
      <td style="text-align: center">128</td>
      <td style="text-align: center">0.12</td>
      <td style="text-align: center">timeout</td>
      <td style="text-align: center">123</td>
      <td style="text-align: center"><strong>128</strong></td>
      <td style="text-align: center">timeout</td>
      <td style="text-align: center">123</td>
      <td style="text-align: center">136</td>
    </tr>
    <tr>
      <td style="text-align: left">DSJC1000.9</td>
      <td style="text-align: center">222</td>
      <td style="text-align: center">2.20</td>
      <td style="text-align: center">timeout</td>
      <td style="text-align: center">215</td>
      <td style="text-align: center"><strong>229</strong></td>
      <td style="text-align: center">timeout</td>
      <td style="text-align: center">215</td>
      <td style="text-align: center">245</td>
    </tr>
    <tr>
      <td style="text-align: left">DSJC125.5</td>
      <td style="text-align: center"><strong>17</strong></td>
      <td style="text-align: center">0.53</td>
      <td style="text-align: center"><strong>70.6</strong></td>
      <td style="text-align: center"><strong>17</strong></td>
      <td style="text-align: center"><strong>17</strong></td>
      <td style="text-align: center">19033</td>
      <td style="text-align: center"><strong>17</strong></td>
      <td style="text-align: center"><strong>17</strong></td>
    </tr>
    <tr>
      <td style="text-align: left">DSJC250.5</td>
      <td style="text-align: center">28</td>
      <td style="text-align: center">43.16</td>
      <td style="text-align: center">timeout</td>
      <td style="text-align: center">26</td>
      <td style="text-align: center">33</td>
      <td style="text-align: center">timeout</td>
      <td style="text-align: center">26</td>
      <td style="text-align: center">31</td>
    </tr>
  </tbody>
</table>

<p><br /></p>

<blockquote>
  <p>Can we ever solve to optimality DSJC500.9 and DSJC1000.9 via Column Enumeration?</p>
</blockquote>

<p>I would say:</p>

<blockquote>
  <p>“Yes, we can!”</p>
</blockquote>

<p>… but likely we need to be smarter while branching on the decision variables, since the default branching strategy of a generic MIP solver does not exploit the structure of the problem. If I had the time to work again on Graph Coloring, I would likely use the same branching scheme used in [2], where we combined a Zykov’s branching rule with a randomized <a href="http://en.wikipedia.org/wiki/Iterative_deepening_depth-first_search">iterative deepening depth-first search</a> (randomised because at each restart we were using a different initial pool of columns). Another interesting option would be to tighten the set covering formulation with valid inequalities, by starting with those studied in [5]. </p>

<p>In conclusion, I believe that enumerating all columns can be a simple but good starting point to attempt to solve to optimality at least the instances DSJC500.9 and DSJC1000.9.</p>

<p>Do you have some spare time and are you willing to take up the challenge?</p>

<h2 id="references">References</h2>
<ol>
  <li>
    <p>A Mehrotra, MA Trick.
<span class="title">A column generation approach for graph coloring</span>.
<span class="journal">INFORMS Journal on Computing</span>. Fall 1996 vol. 8(4), pp.344-354. 
<a href="http://joc.journal.informs.org/content/8/4/344.short ">[pdf]</a></p>
  </li>
  <li>
    <p>S. Gualandi and F. Malucelli.
<span class="title">Exact Solution of Graph Coloring Problems via Constraint Programming and Column Generation</span>.
<span class="journal">INFORMS Journal on Computing</span>. Winter 2012 vol. 24(1), pp.81-100. 
<a href="http://joc.journal.informs.org/content/24/1/81.short">[pdf]</a>
<a href="http://www.optimization-online.org/DB_FILE/2010/03/2568.pdf">[preprint]</a></p>
  </li>
  <li>
    <p>S. Held, W. Cook, E.C. Sewell.
<span class="title">Maximum-weight stable sets and safe lower bounds for graph coloring</span>.
<span class="journal">Mathematical Programming Computation</span>. December 2012, Volume 4, Issue 4, pp 363-381.
<a href="http://link.springer.com/content/pdf/10.1007%2Fs12532-012-0042-3.pdf">[pdf]</a></p>
  </li>
  <li>
    <p>M. Lubbecke and J. Desrosiers.
<span class="title">Selected topics in column generation</span>.
<span class="journal">Operations Research</span>. 2005, Volume 53, Issue 6, pp 1007-1023.
<a href="http://pubsonline.informs.org/doi/abs/10.1287/opre.1050.0234">[pdf]</a></p>
  </li>
  <li>
    <p>
<span class="title">Set covering and packing formulations of graph coloring: algorithms and first polyhedral results</span>.
<span class="journal">Discrete Optimization</span>. 2009, Volume 6, Issue 2, pp 135-147.
<a href="http://www.sciencedirect.com/science/article/pii/S1572528608000716">[pdf]</a></p>
  </li>
</ol>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Big Data and Convex Optimization]]></title>
    <link href="http://stegua.github.io/blog/2014/09/27/big-data-and-convex-optimization/"/>
    <updated>2014-09-27T16:38:00+02:00</updated>
    <id>http://stegua.github.io/blog/2014/09/27/big-data-and-convex-optimization</id>
    <content type="html"><![CDATA[<p>In the last months, I came several times across different definitions of <strong>Big Data</strong>.
However, when someone asks me what Big Data means in practice, I am never
able to give a satisfactory explanation. Indeed, you can easily find a flood
of posts on twitter, blogs, newspaper, and even scientific journals and conferences,
but I always kept feeling that <strong>Big Data</strong> is a buzzword.</p>

<p>By sheer serendipity, this morning I came across <a href="http://web.stanford.edu/~boyd/papers/pdf/admm_distr_stats.pdf">three paragraphs</a> clearly
stating the importance of Big Data from a scientific standpoint, that I like to <strong>cross-post</strong> here (the following paragraphs appear in the introduction of [1]):</p>

<p><em>In all applied fields, it is now commonplace to attack problems through data analysis, particularly through the use of statistical and machine learning algorithms on what are often large datasets. In industry, this trend has been referred to as ‘Big Data’, and it has had a significant impact in areas as varied as artificial intelligence, internet applications, computational biology, medicine, finance, marketing, journalism, network analysis, and logistics.</em></p>

<p><em>Though these problems arise in diverse application domains, they share some key characteristics. First, the datasets are often extremely large, consisting of hundreds of millions or billions of training examples; second, the data is often very high-dimensional, because it is now possible to measure and store very detailed information about each example; and third, because of the large scale of many applications, the data is often stored or even collected in a distributed manner. As a result, it has become of central importance to develop algorithms that are both rich enough to capture the complexity of modern data, and scalable enough to process huge datasets in a parallelized or fully decentralized fashion. Indeed, some researchers have suggested that even highly complex and structured problems may succumb most easily to relatively simple models trained on vast datasets.</em></p>

<blockquote>
  <p>Many such problems can be posed in the framework of <strong>Convex Optimization</strong>. </p>
</blockquote>

<p><em>Given the significant work on decomposition methods and decentralized algorithms in the optimization community, it is natural to look to parallel optimization algorithms as a mechanism for solving large-scale statistical tasks. This approach also has the benefit that one algorithm could be flexible enough to solve many problems.</em></p>

<p>Even if I am not an expert of Convex Optimization [2], I do have my own <strong>mathematical optimization</strong> bias. 
Likely, you may have a different opinion (that I am always happy to hear), but, honestly, the above paragraphs
are the best content that I have read so far about <strong>Big Data</strong>.</p>

<h3 id="references">References</h3>

<p>[1] S. Boyd, N. Parikh, E. Chu, B. Peleato, J. Eckstein.
<em>Distributed Optimization and Statistical Learning via the Alternating Direction Method of Multipliers</em>.
Foundations and Trends in Machine Learning. Vol. 3, No. 1 (2010) 1–122. <a href="http://web.stanford.edu/~boyd/papers/pdf/admm_distr_stats.pdf">[pdf]</a></p>

<p>[2] If you like to have a speedy overview of <em>Convex Optimization</em>, you may read a <a href="https://www.ibm.com/developerworks/community/blogs/jfp/entry/convex_optimization?lang=en">J.F. Puget’s blog post</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The Impact of Preprocessing on the MIPLIB2003]]></title>
    <link href="http://stegua.github.io/blog/2014/03/19/the-impact-of-preprocessing/"/>
    <updated>2014-03-19T22:38:00+01:00</updated>
    <id>http://stegua.github.io/blog/2014/03/19/the-impact-of-preprocessing</id>
    <content type="html"><![CDATA[<p>What do you know about <strong>preprocessing</strong> for <em>Mixed Integer Programming (MIP)</em> problems?</p>

<p>After a nice chat with <a href="http://dk.linkedin.com/in/bojensen">Bo Jensen</a>, CEO, founder, and co-owner (really, he is a Rocket Scientist!) at <a href="http://www.sulumoptimization.com/">Sulum Optimization</a>, I realised that I know barely anything.</p>

<p>By definition, we have that:</p>

<blockquote>
  <p>“Presolving is a way to transform the given problem instance into an equivalent instance that is (hopefully) easier to solve.” (see, chap. 10 in <a href="http://nbn-resolving.de/urn:nbn:de:0297-zib-11129">Tobias Achterberg’s Thesis</a>)</p>
</blockquote>

<p>All I know is that every MIP solver has a <strong>Presolve</strong> parameter, which can take different values.
For instance, <a href="http://www.gurobi.com">Gurobi</a> has three possible values for that parameter (you can find more details on the <a href="http://www.gurobi.com/documentation/5.0/reference-manual/node718#parameter:Presolve">Gurobi online manual</a>):</p>

<ul>
  <li><em>Presolve=0</em>: no presolve at all</li>
  <li><em>Presolve=1</em>: standard presolve</li>
  <li><em>Presolve=2</em>: aggressive presolve: “More aggressive application of presolve takes more time, but can sometimes lead to a significantly tighter model.”</li>
</ul>

<p>However, I can’t tell you the real <strong>impact</strong> of that parameter on the overall solution process of a MIP instance. Thus, here we go: let me write a new post that addresses this basic question!</p>

<h2 id="how-to-measure-the-impact-of-preprocessing">How to measure the Impact of Preprocessing?</h2>
<p>To measure the impact of preprocessing we need four ingredients:</p>

<ol>
  <li>A MIP solver</li>
  <li>A Data set</li>
  <li>Computer power</li>
  <li>A method to <strong>measure</strong> the impact of preprocessing</li>
</ol>

<p>Changing one of the ingredients could give you different results, but, hopefully, the big picture will not change too much.</p>

<p>As a solver, I have selected the current release of Gurobi (i.e., version 5.6.2). For the data set, likely the most critical ingredient, I have used the <a href="http://miplib.zib.de/miplib2003/">MIPLIB2003</a>, basically because I had already all the 60 instances on my server. For running the test I have used an old cluster from the <a href="http://www-dimat.unipv.it">Math Department</a> of University of Pavia.</p>

<p>The <strong>measure of impact</strong> I have decided to use (after considering other alternatives) is quite conservative: the fraction of closed instances as a function of runtime.</p>

<p>During the last weekend, I have collected a bunch of logs for the 60 instances of the MIPLIB2003, and, then, using <a href="http://www.rstudio.com">RStudio</a>, I have draw the following cumulative plot:</p>

<p><img class="center" src="../../../../../../images/preprocessing.png" /></p>

<p>The picture is as simple as clear:</p>

<blockquote>
  <p>Preprocessing does always pay-off and permits to solve around 10% more of the instances within the same time limit!</p>
</blockquote>

<p>In this post, I will not discuss additional technical details, but I just want to add two observations:</p>

<ol>
  <li>Standard preprocessing has removed in average 20.3% of nonzero entries of the original model, while aggressive preprocessing has removed 22.5% of nonzero entries, only a few more.</li>
  <li>The average MIP gaps as reported by Gurobi at timeout are: no-presolve = 13.44%, standard = 9.08%, and aggressive = 11.02%.</li>
</ol>

<p>Likely, the aggressive presolve setting has been decided by Gurobi using a different, much larger, and customer-oriented dataset.</p>

<h2 id="open-questions">Open Questions</h2>
<p>Indeed, preprocessing is a very important feature of a modern MIP solver as Gurobi. Investing few seconds before starting the branch-and-bound MIP search can save a significant amount of runtime. However, a more aggressive preprocessing strategy does not seem to payoff, in average, on the MIPLIB2003.</p>

<p>Unfortunately, preprocessing is somehow disregarded from the research community. There are few recent papers dealing with preprocessing (<em>“ehi! if you do have one, please, let me know about it, ok?”</em>).
Most of papers are from the 90s and about Linear Programming, i.e., without integer variables, which mess up everything.</p>

<p>Here a list of basic questions I have in mind:</p>

<ul>
  <li>If cutting planes are used to approximate the convex hull of an Integer Problem, preprocessing for what is used for, really?</li>
  <li>Preprocessing techniques have been designed considering a trade-off between <strong>efficiency</strong> and <strong>efficacy</strong> (see, MWP Savelsbergh, <em>Preprocessing and Probing Techniques for MIP problems</em>, Journal of Computing, vol6(4) 445-454, 1995). With recent progress in software and hardware technologies, can we revise this trade-off in favor of efficacy?</li>
  <li>Preprocessing techniques used for Linear Programming are effective when applied to LP relaxations of Integer Problems?</li>
  <li>Should preprocessing sparsify the coefficient matrix?</li>
  <li>Using the more recent <a href="http://miplib.zib.de/">MIPLIB2010</a> should we expect much different results?</li>
  <li>Which is a better method to measure the impact of preprocessing on a collection of instances?</li>
</ul>

<p>If you want to share your idea, experience, or opinion, with respect to these questions, you could comment below or send me an email.</p>

<p>Now, to conclude, my bonus question:</p>

<blockquote>
  <p>Do you have any new smart idea for improving preprocessing?</p>
</blockquote>

<p>Well, if you had, I guess you would at least write a paper about, but, do not go for a patent, please!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[An Informal Report from the Combinatorial Optimization Workshop @ Aussois 2014]]></title>
    <link href="http://stegua.github.io/blog/2014/01/13/informal-report-from-cow-at-aussois-2014/"/>
    <updated>2014-01-13T18:30:00+01:00</updated>
    <id>http://stegua.github.io/blog/2014/01/13/informal-report-from-cow-at-aussois-2014</id>
    <content type="html"><![CDATA[<p>It is very hard to report about the <a href="http://www.iasi.cnr.it/aussois/web/home">Combinatorial Optimization Workshop</a> in <a href="http://www.aussois.com/hiver/">Aussois</a>. It was like an “informal” <a href="http://www.or.uni-bonn.de/ipco/">IPCO</a> with <em>Super Heroes researchers</em> in the audience, leaded by <em>Captain Egon</em>, who appears at work in the following photo-tweet:</p>

<blockquote class="twitter-tweet" lang="en"><p>Egon talks intersection cuts at <a href="https://twitter.com/search?q=%23aussois&amp;src=hash">#aussois</a>. Still the man. <a href="http://t.co/7KMcNyJYV0">pic.twitter.com/7KMcNyJYV0</a></p>&mdash; Jeff Linderoth (@JeffLinderoth) <a href="https://twitter.com/JeffLinderoth/statuses/420852308583276544">January 8, 2014</a></blockquote>
<script async="" src="http://stegua.github.io//platform.twitter.com/widgets.js" charset="utf-8"></script>

<p>The Captain gave an inspiring talk by questioning the recursive paradigm of cutting planes algorithms. With a very basic example, <a href="http://public.tepper.cmu.edu/facultydirectory/FacultyDirectoryProfile.aspx?id=39">Balas</a> has shown how a non basic vertex (solution) can produce a much deeper cut than a cut generated by an optimal basis. Around this intuition, Balas has presented a very nice <a href="http://link.springer.com/article/10.1007%2Fs10107-011-0483-x">generalization of Intersection Cuts</a>… a new paper enters my “PAPERS-TO-BE-READ” folder.</p>

<p>To stay on the subject of cutting planes, the talk by Marco Molinaro in the first day of the workshop was really nice. He raises the fundamental question on how important are <strong>sparse cuts</strong> versus <strong>dense cuts</strong>. The importance of sparse cuts comes from linear algebra: when solving the simplex it is better to have small determinants in the coefficient matrix of the Linear Programming relaxation in order to avoid numerical issues; sparse cuts implicitly help in keeping small the determinants (intuitively, you have more zeros in the matrix). Dense cuts play the opposite role, but they can be really important to improve the bound of the LP relaxation.
In his talk, Molinaro has shown and proofed, for three particular cases, when sparse cuts are enough, and when they are not. 
Another paper goes on the “PAPERS-TO-BE-READ” folder.</p>

<p>In the same day of Molinaro, it was really inspiring the talk by Sebastian Pokutta, who really gave a completely new (for me) perspective on <strong>Extended Formulations</strong> by using <a href="http://en.wikipedia.org/wiki/Information_theory">Information Theory</a>. Sebastian is the author of a <a href="http://spokutta.wordpress.com/">blog</a>, and I hope he will post about his talk.</p>

<p>Andrea Lodi has discussed about an Optimization problem that arises in Supervised Learning.  For this problem, the COIN-OR solver <a href="http://www.coin-or.org/Couenne/">Couenne</a>, developed by Pietro Belotti, significantly outperforms <a href="http://www-01.ibm.com/software/commerce/optimization/cplex-optimizer/">CPLEX</a>. The issues seem to come from on a number of basic big-M (indicator) constraints. To make a long story short, if you have to solve a hard problem, it does pay off to try different solvers, since there is not a “win-all” solver. </p>

<blockquote>
  <p>Do you have an original new idea for developing solvers? Do not be intimidated by <a href="http://www-01.ibm.com/software/commerce/optimization/cplex-optimizer/">CPLEX</a> or <a href="http://www.gurobi.com/">Gurobi</a> and go for it!</p>
</blockquote>

<p>The presentation by Marco Senatore was brilliant and his work looks very interesting. I have particularly enjoyed the application in Public Transport that he has mentioned at the end of his talk.</p>

<p>I recommend to have a look at the presentation of Stephan Held about the <strong>Reach-aware Steiner Tree Problem</strong>. He has an interesting Steiner tree-like problem with a very important application in chip design. The presentation has impressive pictures of what optimal solutions look like in chip design.</p>

<p>At the end of talk, Stephan announced the <a href="http://dimacs11.cs.princeton.edu/">11th DIMACS challenge on Steiner Tree Problems</a>.</p>

<p>Eduardo Uchoa gave another impressive presentation on recent progresses on the classical <strong>Capacitated Vehicle Routing Problem</strong> (CVRP). He has a very sophisticated branch-and-price-and-cut algorithm, which comes with a very efficient implementation of every possible idea developed for CVRP, plus new ideas on solving efficiently the pricing sub problems (my understanding, but I might be wrong, is that they have a very efficient dominance rule for solving a shortest path sub problem). 
+1 item in the “PAPERS-TO-BE-READ” folder.</p>

<p>The last day of the workshop, I have enjoyed the two talks by Simge Kucukyavuz and Jim Luedtke on <strong>Stochastic Integer Programming</strong>: for me is a completely new topic, but the two presentations were really inspiring.</p>

<p>To conclude, Domenico Salvagnin has shown how far it is possible to go by carefully using MIP technologies such as <strong>cutting planes</strong>, <strong>symmetry handling</strong>, and <strong>problem decomposition</strong>. Unfortunately, it does happen too often that when someone (typically a non OR expert) has a difficult application problem, he writes down a more or less complicated Integer Programming model, tries a solver, sees it takes too much time, and gives up with exact methods. Domenico, by solving the largest unsolved instance for the 3-dimensional assignment problem, has shown that </p>

<blockquote>
  <p>there are potentially no limits for MIP solvers!</p>
</blockquote>

<p>In this post, I have only mentioned a few talks, which somehow overlap with my research interests. However, every talk was really interesting. Fortunately, Francois Margot has strongly encouraged all of the speakers to upload their slides and/or papers, so you can find (almost) all of them on the <a href="http://www.iasi.cnr.it/aussois/web/home/program/year/2014">program web page of the workshop</a>. Visit the website and have a nice reading!</p>

<p>To conclude, let me steal another nice picture from twitter: </p>

<blockquote class="twitter-tweet" lang="en"><p>Goodbye <a href="https://twitter.com/search?q=%23aussois2014&amp;src=hash">#aussois2014</a> <a href="http://t.co/ODupKKmGTZ">pic.twitter.com/ODupKKmGTZ</a></p>&mdash; Matteo Fischetti (@MFischetti) <a href="https://twitter.com/MFischetti/statuses/421642338759618560">January 10, 2014</a></blockquote>
<script async="" src="http://stegua.github.io//platform.twitter.com/widgets.js" charset="utf-8"></script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Public Transport and Big Data]]></title>
    <link href="http://stegua.github.io/blog/2013/11/17/public-transport-and-big-data/"/>
    <updated>2013-11-17T14:10:00+01:00</updated>
    <id>http://stegua.github.io/blog/2013/11/17/public-transport-and-big-data</id>
    <content type="html"><![CDATA[<p><strong>Big Data</strong> is nowadays a <em>buzzword</em>. A simple query for “Big Data” on Google gives about 26,700,000 results. </p>

<p><strong>Public Transport</strong> is not really a <em>buzzword</em>, but still on Google you can get almost the same number as with “Big Data”: 26,400,000 results.</p>

<h3 id="why-is-public-transport-so-important">Why is Public Transport so important?</h3>

<p>Because <em>many</em> of us use <a href="http://en.wikipedia.org/wiki/Public_transport">Public Transport</a> every day, but <em>most</em> of us still use their own car to go to work, to bring child at school, and to go shopping. This has a negative impact on the quality of life of everyone and is clearly inefficient since it does cost more: </p>

<ol>
  <li>More money.</li>
  <li>More pollution.</li>
  <li>More time.</li>
</ol>

<p>(Well, for time, it is not always true, but it happens more often than commonly perceived). </p>

<p>Thus, an important <strong>challenge</strong> is to improve the quality of Public Transport while keeping 
its cost competitive. The ultimate goal should be to increase the number of people that <strong>trust</strong> and use Public Transport.</p>

<p>How is it possible to achieve this goal?</p>

<h3 id="transport-operators-are-big-data-producers-are-they">Transport Operators are <strong>Big Data</strong> producers (are they?)</h3>

<p>Modern transport operators have installed so called <em>Automatic Vehicle Monitoring (AVM)</em> systems that use several technologies to monitor the fleet of vehicles that operates the service (e.g., metro coaches, buses, metro trains, trains, …).</p>

<p>The stream of data produced by an AVM might be considered as <strong>Big Data</strong> because of its <strong>volume</strong> and <strong>velocity</strong> (see <a href="https://www.ibm.com/developerworks/community/blogs/jfp/entry/big_data_for_dummies23?lang=en">Big Data For Dummies</a>, by J.F. Puget). Each vehicle produces at regular intervals (measured in seconds) data concerning its position and status. This information is stored in remote data centers. The data for a single day might not be considered as “Big”, however once you start to analyze the historical data, the volume increases significantly. For instance, a public transport operator could easily have around 2000 thousands vehicles that operate 24 hours a day, producing data potentially every second.</p>

<p>At the moment, this stream of data misses the third dimension of Big Data that is <strong>variety</strong>. However, new projects that aim at integrating this information with the stream of data coming from social networks are quickly reaching maturity. One of such project is <a href="http://www.superhub-project.eu/">SuperHub</a>, a FP7 project that has recently won the best exhibit award in Cluster 2 <em>“Smart and sustainable cities for 2020+”</em>, at the <a href="http://www.superhub-project.eu/media-centre/124-ict2013-conference-best-exhibit-award-.html">ICT2013 Conference</a> in Vilnius.</p>

<p>I don’t know whether transport operators are really <strong>Big Data</strong> producers or they are merely <strong>Small Data</strong> producers, but data collected using AVMs are nowadays mainly used to report and monitor the daily activities.</p>

<p>In my own opinion, the data produced by transport operators, integrated with input coming from social networks, should be used to improve the quality of the public transport, for instance, by trying to better tackle <strong>Disruption Management</strong> issues.</p>

<p>So, I am curious:</p>

<blockquote>
  <p>Do you know any project that uses AVM data, combined with Social Network inputs (e.g., from <a href="http://www.twitter.com">Twitter</a>), to elaborate <strong>Disruption Management</strong> strategies for Public Transport? If yes, do they use <strong>Mathematical Optimization</strong> at all?</p>
</blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Reading Excuses]]></title>
    <link href="http://stegua.github.io/blog/2013/11/01/reading-excuses/"/>
    <updated>2013-11-01T15:56:00+01:00</updated>
    <id>http://stegua.github.io/blog/2013/11/01/reading-excuses</id>
    <content type="html"><![CDATA[<p>I love reading!</p>

<p>I love reading about everything and I am glad that part of my work consists in reading.</p>

<p>Unfortunately, for researchers, reading is not always that easy, as clearly explained in <strong><a href="http://homepages.inf.ed.ac.uk/bundy/how-tos/resbible.html">The Researcher’s Bible</a></strong>:</p>

<blockquote>
  <p>Reading is difficult: The difficulty seems to depend on the stage of academic development. Initially it is hard to know what to read (many documents are unpublished), later reading becomes seductive and is used as an excuse to avoid research. Finally one lacks the time and patience to keep up with reading (and fears to find evidence that one’s own work is second rate or that one is slipping behind)</p>
</blockquote>

<p>For my <em>stage of academic development</em>, reading is <strong>extremely seductive</strong>, and the situation became even worse after reading the answers to the following question raised by <a href="http://mat.tepper.cmu.edu/blog">Michael Trick</a> on <a href="https://www.or-exchange.org/">OR-exchange</a>:</p>

<blockquote>
  <p><a href="https://www.or-exchange.org/questions/681/what-paper-should-everyone-read">What paper should everyone read?</a></p>
</blockquote>

<p>If you are looking for excuses to avoid research, go through <a href="https://www.or-exchange.org/questions/681/what-paper-should-everyone-read">those answers</a> and select any paper you like, you will have <strong>outstanding</strong> and <strong>authoritative</strong> excuses!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[GeCol: a Graph Coloring solver on top of Gecode]]></title>
    <link href="http://stegua.github.io/blog/2013/06/28/gecol/"/>
    <updated>2013-06-28T15:00:00+02:00</updated>
    <id>http://stegua.github.io/blog/2013/06/28/gecol</id>
    <content type="html"><![CDATA[<style type="text/css">
.title { color: #07235F; }
.journal { font-style: italic; }
</style>

<p>This post is about solving the classical <strong>Graph Coloring</strong> problem by using a simple solver, named here <strong>GeCol</strong>, that is built on top of the Constraint Programming (CP) solver <a href="http://www.gecode.org">Gecode</a>. The approach of GeCol is based on the CP model described in [1]. Here, we want to explore some of the new features of the last version of Gecode (version 4.0.0), namely: </p>

<ul>
  <li><em>Lightweight Dynamic Symmetry Breaking (LDSB)</em> [2]</li>
  <li><em>Accumulated Failure Count (AFC)</em> and <em>Activity-based</em> strategies for variable selection while branching, combined with <em>Restart Based Search</em></li>
</ul>

<p>We are going to present computational results using these features to solve the <a href="https://sites.google.com/site/graphcoloring/vertex-coloring">instances</a> of the <a href="http://dimacs.rutgers.edu/Challenges/">Graph Coloring DIMACS Challenge</a>. However, this post is not going to describe in great details what these features are: please, for this purpose, refer to the <a href="http://www.gecode.org/doc-latest/MPG.pdf">Modeling and Programming with Gecode</a> book.</p>

<p>As usual, all the sources used to write this post are publicly available on 
<a href="https://github.com/stegua/MyBlogEntries/tree/master/Coloring">my GitHub repository</a>.</p>

<h3 id="modeling-graph-coloring-with-constraint-programming">Modeling Graph Coloring with Constraint Programming</h3>

<p>Given an undirected graph <script type="math/tex">G=(V,E)</script> and a set of colors <script type="math/tex">K</script>, the minimum (vertex) graph coloring problem consists of assigning a color to each vertex, while every pair of adjacent vertices gets a different color. The objective is to minimize the number of colors.</p>

<p>To model this problem with CP, we can use for each vertex <script type="math/tex">i</script> an integer variable <script type="math/tex">x_i</script> with domain equals to <script type="math/tex">K</script>: if <script type="math/tex">x_i=k</script>, then color <script type="math/tex">k</script> is assigned to vertex <script type="math/tex">i</script>.
Using (inclusion-wise) <em>maximal cliques</em>, it is possible to post constraints on subsets of adjacent vertices: every subset of vertices belonging to the same clique must get a different color. In CP, we can use the well-known <code>alldifferent</code> constraint for posting these constraints.</p>

<p>In practice, to build our CP model, first, we find a collection of maximal cliques <script type="math/tex">C</script>, such that for every edge <script type="math/tex">(i,j) \in E</script> there exists at least a clique <script type="math/tex">c \in C</script> that contains both vertices <script type="math/tex">i</script> and <script type="math/tex">j</script>. Second, we post the following constraints:</p>

<script type="math/tex; mode=display">\mbox{alldifferent}([x_c]) \qquad \forall c \in C</script>

<p>where <script type="math/tex">x_c</script> denotes the subset of variables corresponding to the vertices that belong to the clique <script type="math/tex">c</script>.</p>

<p>In order to minimize the number of colors, we use a simple iterative procedure. Every time we found a coloring with <script type="math/tex">k</script> colors, we restart the search by restricting the cardinality of <script type="math/tex">K</script> to <script type="math/tex">k-1</script>. If no feasible coloring exists with <script type="math/tex">k-1</script> colors, we have proved optimality for the last feasible coloring found, i.e. <script type="math/tex">\chi(G)=k</script>.</p>

<p>In addition, we apply a few basic preprocessing steps that are described in [1].
The maximal cliques are computed using <strong>Cliquer v1.21</strong> [5].</p>

<h3 id="lightweight-dynamic-symmetry-breaking">Lightweight Dynamic Symmetry Breaking</h3>

<p>The Graph Coloring problem is an optimization problem that has several equivalent optimum solutions: for instance, given an optimal assignment of colors to vertices, any permutation of the colors, gives a solution with the same optimum value.</p>

<p>While this property is implicitly considered in <em>Column Generation approaches</em> to Graph Coloring (e.g., see [3], [1], and [4]), the CP model we have just presented, suffers from symmetries issues: the values of the domains of the integer variables are symmetric.</p>

<p>The <strong>Lightweight Dynamic Symmetry Breaking</strong> is a strategy for dealing with this issue [2].
In Gecode, you can define a set of values that are symmetric as follows:</p>

<p><code>Symmetries syms;
 syms &lt;&lt; ValueSymmetry(IntArgs::create(k,1));</code></p>

<p>and then when posting the branching strategy you just write (just note that use of object <code>syms</code>):</p>

<p><code>branch(*this, x, INT_VAR_SIZE_MIN(), INT_VAL_MIN(), syms);</code></p>

<p>With <strong><em>three lines of code</em></strong>, you have solved (some of) the symmetry issues.</p>

<blockquote>
  <p>How efficient is <em>Lightweight Dynamic Symmetry Breaking</em> for Graph Coloring?</p>
</blockquote>

<p>We try to answer to this question with the plot below that shows the results for two versions of GeCol:</p>

<ul>
  <li>(A) The first version without any breaking symmetry strategy</li>
  <li>(B) The second version with the Lightweight Dynamic Breaking Symmetry</li>
</ul>

<p>Both versions select for branching the variable with the smallest domain size.
The plot reports the empirical cumulative distribution as function of run time (in log-scale).
The tests were run with a timeout of 300 seconds on a quite old server. 
Note that at the timeout, the version with LDBS has solved around 55% of the instances, while the version without LDBS has solved only around 48% of the instances.</p>

<p><img class="center" src="../../../../../../images/Ecdf1.png" /></p>

<h3 id="accumulated-failure-count-and-activity-based-branching">Accumulated Failure Count and Activity-based Branching</h3>
<p>The second new feature of Gecode that we explore here is the <em>Accumulated Failure Count</em> and the <em>Activity-based</em> branching strategies.</p>

<p>While solving any CP model, the strategy used to select the next variable to branch over is very important. The <em>Accumulated Failure Count</em> strategy stores the cumulative number of failures for each variable (for details see Section 8.5 in <a href="http://www.gecode.org/doc-latest/MPG.pdf">MPG</a>). The <em>Activity-based</em> search does something similar, but instead of counting failures, measures the activity of each variable.
In a sense, these two strategies try to <em>learn</em> from failures and activities as they occur during the search process. </p>

<p>These two branching strategies are more effective when combined with <em>Restart Based Search</em>: the solver performs the search with increasing cutoff values on the number of failures. Gecode offers several optional strategies to improve the cutoff. In our tests, we have used a geometric cutoff sequence (Section 9.4 in <a href="http://www.gecode.org/doc-latest/MPG.pdf">MPG</a>).</p>

<blockquote>
  <p>How effective are the <strong>Accumulated Failure Count</strong> and the <strong>Activity-based</strong> strategies for Graph Coloring when combined with <strong>Restart Based Search</strong>?</p>
</blockquote>

<p>The second plot below shows a comparison of 3 versions of GeCol, with 3 different branching strategies:</p>

<ul>
  <li>(A) Select the variable with smallest domain size</li>
  <li>(B) Select the variable with largest Activity Cumulated value</li>
  <li>(C) Select the variable with largest Accumulated Failure Count (AFC) value</li>
</ul>

<p>The last strategy is tremendously efficient: it dominates the other two strategies, and it is able to solve more of the 60% of the considered instances within the timeout of 300 seconds.</p>

<p><img class="center" src="../../../../../../images/Ecdf2.png" /></p>

<p>However, it is possible to do still slightly better. Likely, at the begging of the search phase, several variables have the same value of AFC. Therefore, it is possible to improve the branching strategy by breaking ties: we can divide the ACT or the AFC value of a variable by the its domain size. The next plot shows the results with these other branching strategies:</p>

<ul>
  <li>(A) Select the variable with largest ratio of variable degree vs. domain size</li>
  <li>(B) Select the variable with largest ratio of Activity Cumulated value vs. domain size</li>
  <li>(C) Select the variable with largest ratio of Accumulated Failure Count vs. domain size</li>
</ul>

<p><img class="center" src="../../../../../../images/Ecdf3.png" /></p>

<h2 id="conclusions">Conclusions</h2>
<p>The new features of Gecode are very interesting and offer plenty of options.
The LDBS is very general, and it could be easily applied to several other combinatorial optimization problems.
Also the new branching strategies gives important enhancements, above all when combined with restart based search.</p>

<blockquote>
  <p>”…with great power there must also come – great responsibility!” (Uncle Ben, The Amazing Spider-Man, n.660, Marvel Comics) </p>
</blockquote>

<p>As a drawback, it is becoming harder and harder to find the best parameter configuration for solvers as Gecode (but this is true also for other type of solvers, e.g. Gurobi and Cplex).</p>

<p>Can you find or suggest a better parameter configuration for GeCol?</p>

<h2 id="references">References</h2>
<ol>
  <li>
    <p>S. Gualandi and F. Malucelli.
<span class="title">Exact Solution of Graph Coloring Problems via Constraint Programming and Column Generation</span>.
<span class="journal">INFORMS Journal on Computing</span>. Winter 2012 vol. 24(1), pp.81-100. 
<a href="http://joc.journal.informs.org/content/24/1/81.short">[pdf]</a>
<a href="http://www.optimization-online.org/DB_FILE/2010/03/2568.pdf">[preprint]</a></p>
  </li>
  <li>
    <p>C. Mears, M.G. de la Banda, B. Demoen, M. Wallace.
<span class="title">Lightweight dynamic symmetry breaking</span>.
<span class="journal">In Eighth International Workshop on Symmetry in Constraint Satisfaction Problems,
SymCon’08, 2008.</span> 
<a href="http://www.aloul.net/symcon/Mears2-Symcon08.pdf">[pdf]</a></p>
  </li>
  <li>
    <p>A Mehrotra, MA Trick.
<span class="title">A column generation approach for graph coloring</span>.
<span class="journal">INFORMS Journal on Computing</span>. Fall 1996 vol. 8(4), pp.344-354. 
<a href="http://joc.journal.informs.org/content/8/4/344.short ">[pdf]</a></p>
  </li>
  <li>
    <p>S. Held, W. Cook, E.C. Sewell.
<span class="title">Maximum-weight stable sets and safe lower bounds for graph coloring</span>.
<span class="journal">Mathematical Programming Computation</span>. December 2012, Volume 4, Issue 4, pp 363-381.
<a href="http://link.springer.com/content/pdf/10.1007%2Fs12532-012-0042-3.pdf">[pdf]</a></p>
  </li>
  <li>
    <p>Patric R.J. Ostergard.
<span class="title">A fast algorithm for the maximum clique problem</span>.
<span class="journal">Discrete Applied Mathematics</span>, 
vol. 120(1-3), pp. 197–207, 2002
<a href="http://citeseerx.ist.psu.edu/viewdoc/similar?doi=10.1.1.28.7666&amp;type=cc">[pdf]</a>
</p>
  </li>
</ol>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Backtrack Programming in c]]></title>
    <link href="http://stegua.github.io/blog/2013/03/22/backtrack-programming-in-c/"/>
    <updated>2013-03-22T12:45:00+01:00</updated>
    <id>http://stegua.github.io/blog/2013/03/22/backtrack-programming-in-c</id>
    <content type="html"><![CDATA[<style type="text/css">
.title { color: #07235F; }
.journal { font-style: italic; }
</style>

<p>Recently, I have discovered a nice tiny library (1 file!) that supports <a href="http://en.wikipedia.org/wiki/Backtracking">Backtrack Programming</a> in <strong>standard C</strong>.
The library is called <a href="http://www.akira.ruc.dk/~keld/research/CBACK/">CBack</a> and 
is developed by <a href="http://www.akira.ruc.dk/~keld/">Keld Helsgaun</a>, who is known in the Operations Research 
and Computer Science communities for his efficient implementation of the 
Lin-Kernighan heuristics for the <a href="http://www.akira.ruc.dk/~keld/research/LKH/">Travelling Salesman Problem</a>.</p>

<p><strong>CBack</strong> offers basically two functions that are described in [1] as follows:</p>

<ol>
  <li><strong><code>Choice(N)</code></strong>: “<em>is used when a choice is to be made among a number of alternatives, where <strong>N</strong> is a positive integer denoting the number of alternatives</em>”.</li>
  <li><strong><code>Backtrack()</code></strong>: “<em>causes the program to backtrack, that is to say, return to the most recent call of Choice, which has not yet returned all its values</em>”.</li>
</ol>

<p>With these two functions is pretty simple to develop exact enumeration algorithms.
The <strong>CBack</strong> library comes with several examples, such as algorithms for the <a href="http://en.wikipedia.org/wiki/Eight_queens_puzzle">N-queens</a> problem and the <a href="http://en.wikipedia.org/wiki/15_puzzle">15-puzzle</a>.
Below, I will show you how to use <strong>CBack</strong> to implement a simple algorithm that finds a <a href="http://en.wikipedia.org/wiki/Clique_problem">Maximum Clique</a> in an undirected graph.</p>

<p>As usual, the source code used to write this post is publicly available on
<a href="https://github.com/stegua/MyBlogEntries/tree/master/Backtracking">my GitHub repository</a>.</p>

<h2 id="basic-use-of-cback">Basic use of CBack</h2>
<p>The <strong>CBack</strong> documentation shows as first example the following code snippet:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>Example</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span></span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
</span><span class="line"><span class="n">i</span> <span class="o">=</span> <span class="n">Choice</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
</span><span class="line"><span class="n">j</span> <span class="o">=</span> <span class="n">Choice</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
</span><span class="line"><span class="n">printf</span><span class="p">(</span><span class="s">&quot;i = %d, j = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">);</span>
</span><span class="line"><span class="n">Backtrack</span><span class="p">();</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>The output produced by the snippet is:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>Output</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span></span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span>
</span><span class="line"><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">2</span>
</span><span class="line"><span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span>
</span><span class="line"><span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">2</span>
</span><span class="line"><span class="n">i</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span>
</span><span class="line"><span class="n">i</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">2</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>If you are familiar with backtrack programming (e.g., <a href="http://en.wikipedia.org/wiki/Prolog">Prolog</a>), you should not be surprised by the output, and you can jump to the next section. Otherwise, 
the Figure below sketches the program execution. </p>

<p><img src="http://stegua.github.io/images/backtrack.png" /></p>

<p>When the program executes the <code>Choice(N=3)</code> statement, that is the first call to the first choice (line 2), value 1 is assigned to variable <code>i</code>. Behind the scene, the <em>Choice</em> function stores the current execution state of the program in its own stack,
and records the next possible choices (i.e. the other possible program branches),
that are values <code>2</code> and <code>3</code>. Next, the second <code>Choice(N=2)</code> assigns value 1 to <code>j</code> (line 3),
and again the state of the program is stored for later use. Then, the <code>printf</code> outputs <code>i = 1 , j = 1</code> (line 4 and first line of output). Now, it is time to <em>backtrack</em> (line 5). </p>

<p>What is happening here?</p>

<p>Look again at the figure above: When the <code>Backtrack()</code> function is invoked, the algorithm <em>backtracks</em> and continues the execution
from the most recent <strong>Choice</strong> stored in its stack, i.e. it assigns to variable <code>j</code> value 2, and <code>printf</code> outputs <code>i = 1, j = 2</code>. Later, the <code>Backtrack()</code> is invoked again, and this time the algorithm backtracks until the previous possible choice that corresponds to the assignment of value 2 to variable <code>i</code>, and it executes <code>i = 2</code>. Once the second choice for variable <code>i</code> is performed, there are again two possible choices for variable <code>j</code>, since the program has backtracked to a point that precedes that statement. Thus, the program executes <code>j = 1</code>, and <code>printf</code> outputs <code>i = 2, j = 1</code>. At this point, the program <em>backtracks</em> again, and consider the next possible choice, <code>j = 2</code>. This is repeated until all possible choices for <code>Choice(3)</code> and <code>Choice(2)</code> are exhausted, yielding the 6 possible combinations of <code>i</code> and <code>j</code> that the problem gave as output.</p>

<p>Indeed, during the execution, the program has implicitly visited in a depth-first manner the <em>search tree</em> of the previous figure.
CBack supports also different search strategy, such as <em>best first</em>, but I will not cover that topic here.</p>

<p>In order to store and restore the program execution state (well, more precisely the <em>calling environment</em>), <code>Choice(N)</code> and <code>Backtrack</code> use two <strong>threatening</strong> C standard functions, <code>setjmp</code> and <code>longjmp</code>. 
For the details of their use in CBack, see [1].</p>

<h2 id="a-basic-maximum-clique-algorithm">A Basic Maximum Clique Algorithm</h2>
<p>The reason why I like this library, apart from remembering me the time I was programming with <a href="http://www.mozart-oz.org/">Mozart</a>, is that it permits to implement quickly exact algorithms based on enumeration. While enumeration is usually disregarded as <em>inefficient</em> (“<em>ehi, it is just brute force</em>!”), it is still one of the best method to solve small instances of almost any combinatorial optimization problem. In addition, many sophisticated exact algorithms use plain enumeration as a subroutine, when during the search process the size of the problem becomes small enough.</p>

<p>Consider now the <strong>Maximum Clique Problem</strong>: Given an undirected graph <script type="math/tex">G=(V,E)</script>, the problem is to find the largest complete subgraph of <script type="math/tex">G</script>. More formally, you look for the largest subset <script type="math/tex">C</script> of the vertex set <script type="math/tex">V</script> such that for any pair of nodes <script type="math/tex">{i,j}</script> in <script type="math/tex">C \times C</script> there exists an arc <script type="math/tex">{i,j} \in E</script>.  </p>

<p>The well-known branch-and-bound algorithm of Carraghan and Pardalos [2] is based on enumeration. The implementation of Applegate and Johnson, called <a href="ftp://dimacs.rutgers.edu/pub/dsj/clique/dfmax.c">dfmax.c</a>, is a very efficient implementation of that algorithm. Next, I show a basic implementation of the same algorithm that uses <strong>CBack</strong> for backtracking.</p>

<p>The Carraghan and Pardalos algorithm uses three sets: the current clique <script type="math/tex">C</script>, the largest clique found so far <script type="math/tex">C^*</script>, and the set of candidate vertices <script type="math/tex">P</script>. The pseudo code of the algorithm is as follows (as described in [3]):</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>Basic Maximum Clique Algorithm</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span></span><span class="n">function</span> <span class="nf">findClique</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">P</span><span class="p">)</span>
</span><span class="line">   <span class="k">if</span> <span class="o">|</span><span class="n">C</span><span class="o">|</span> <span class="o">&gt;</span> <span class="o">|</span><span class="n">C</span><span class="o">*|</span> <span class="n">then</span> <span class="n">C</span><span class="o">*</span> <span class="o">&lt;-</span> <span class="n">C</span>  <span class="c1">// store the best clique</span>
</span><span class="line">   <span class="k">if</span> <span class="o">|</span><span class="n">C</span><span class="o">|</span> <span class="o">+</span> <span class="o">|</span><span class="n">P</span><span class="o">|</span> <span class="o">&gt;</span> <span class="o">|</span><span class="n">C</span><span class="o">*|</span> <span class="n">then</span>
</span><span class="line">      <span class="k">for</span> <span class="n">all</span> <span class="n">v</span> <span class="n">in</span> <span class="n">P</span> <span class="c1">// the order does matter </span>
</span><span class="line">         <span class="n">P</span> <span class="o">&lt;-</span> <span class="n">P</span> <span class="err">\</span> <span class="p">{</span><span class="n">v</span><span class="p">}</span>
</span><span class="line">         <span class="n">C</span><span class="err">&#39;</span> <span class="o">&lt;-</span> <span class="n">C</span> <span class="n">u</span> <span class="p">{</span><span class="n">v</span><span class="p">}</span>
</span><span class="line">         <span class="n">P</span><span class="err">&#39;</span> <span class="o">&lt;-</span> <span class="n">P</span>  <span class="err">\</span><span class="n">intersect</span> <span class="n">N</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>  <span class="c1">// neighbors of p</span>
</span><span class="line">         <span class="n">findClique</span><span class="p">(</span><span class="n">C</span><span class="err">&#39;</span><span class="p">,</span> <span class="n">P</span><span class="err">&#39;</span><span class="p">)</span>
</span><span class="line">
</span><span class="line"><span class="n">function</span> <span class="n">main</span><span class="p">()</span>
</span><span class="line">   <span class="n">C</span><span class="o">*</span> <span class="o">&lt;-</span> <span class="p">{}</span>  <span class="c1">// empty set, C* global variable</span>
</span><span class="line">   <span class="n">findClique</span><span class="p">({},</span><span class="n">V</span><span class="p">)</span>
</span><span class="line">   <span class="k">return</span> <span class="n">C</span><span class="o">*</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>As you can see, the backtracking is here described in terms of a recursive function. However, using CBack, we can implement the same algorithm without using recursion.</p>

<h2 id="maximum-clique-with-cback">Maximum Clique with CBack</h2>
<p>We use an array <code>S</code> of <script type="math/tex">n</script> integers, one for each vertex of <script type="math/tex">V</script>.
If <code>S[v]=0</code>, then vertex <script type="math/tex">i</script> belongs to the candidate set <script type="math/tex">P</script>; if <code>S[v]=1</code>, then vertex <script type="math/tex">i</script> is in <script type="math/tex">C</script>; if <code>S[v]=2</code>, then vertex <script type="math/tex">i</script> cannot be neither in <script type="math/tex">P</script> nor in <script type="math/tex">C</script>. The variable <code>s</code> stores the size of current clique.</p>

<p>Let me show you directly the C code:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>Max Clique via Branch-and-Bound</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span></span><span class="k">for</span> <span class="p">(</span><span class="n">v</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">v</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">v</span><span class="o">++</span> <span class="p">)</span> <span class="p">{</span>
</span><span class="line">   <span class="c1">/// If the current clique cannot be extended to a clique</span>
</span><span class="line">   <span class="c1">/// larger than C*, where LB=|C*|, then backtrack</span>
</span><span class="line">   <span class="k">if</span> <span class="p">(</span> <span class="n">s</span> <span class="o">+</span> <span class="n">P</span> <span class="o">&lt;=</span> <span class="n">LB</span> <span class="p">)</span>
</span><span class="line">      <span class="n">Backtrack</span><span class="p">();</span>
</span><span class="line">   <span class="k">if</span> <span class="p">(</span> <span class="n">S</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="p">)</span> <span class="p">{</span>  <span class="c1">/// Skip removed vertices  </span>
</span><span class="line">      <span class="c1">/// Choice: Either v is in C (S[v]=1) or is not (S[v]=2)</span>
</span><span class="line">      <span class="n">S</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">Choice</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
</span><span class="line">      <span class="k">if</span> <span class="p">(</span> <span class="n">S</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span> <span class="p">)</span> <span class="p">{</span> <span class="c1">/// P &lt;- P \ {v} </span>
</span><span class="line">         <span class="n">P</span><span class="o">--</span><span class="p">;</span>  <span class="c1">/// Decrease the size of the candidate set </span>
</span><span class="line">      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="c1">/// S[v]=1: C &lt;- C u {v}</span>
</span><span class="line">         <span class="n">s</span><span class="o">++</span><span class="p">;</span>   <span class="c1">/// Update current clique size </span>
</span><span class="line">         <span class="k">if</span> <span class="p">(</span> <span class="n">s</span> <span class="o">&gt;</span> <span class="n">LB</span> <span class="p">)</span> <span class="p">{</span>
</span><span class="line">            <span class="n">LB</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>  <span class="c1">/// Store the new best clique</span>
</span><span class="line">            <span class="k">for</span> <span class="p">(</span> <span class="n">w</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">w</span> <span class="o">&lt;=</span> <span class="n">v</span><span class="p">;</span> <span class="n">w</span><span class="o">++</span> <span class="p">)</span>
</span><span class="line">               <span class="n">C</span><span class="p">[</span><span class="n">w</span><span class="p">]</span> <span class="o">=</span> <span class="n">S</span><span class="p">[</span><span class="n">w</span><span class="p">];</span>
</span><span class="line">         <span class="p">}</span>
</span><span class="line">         <span class="c1">/// Restrict the candidate set </span>
</span><span class="line">         <span class="k">for</span> <span class="p">(</span> <span class="n">w</span> <span class="o">=</span> <span class="n">V</span><span class="p">[</span><span class="n">v</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span> <span class="n">w</span> <span class="o">&gt;</span> <span class="n">V</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="p">;</span> <span class="n">w</span><span class="o">--</span> <span class="p">)</span>
</span><span class="line">            <span class="k">if</span> <span class="p">(</span> <span class="n">S</span><span class="p">[</span><span class="n">E</span><span class="p">[</span><span class="n">w</span><span class="p">]]</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
</span><span class="line">               <span class="n">S</span><span class="p">[</span><span class="n">E</span><span class="p">[</span><span class="n">w</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
</span><span class="line">               <span class="n">P</span><span class="o">--</span><span class="p">;</span> <span class="c1">/// Decrease the size of the candidate set </span>
</span><span class="line">            <span class="p">}</span>
</span><span class="line">      <span class="p">}</span>
</span><span class="line">   <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line"><span class="n">Backtrack</span><span class="p">();</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Well, I like this code pretty much, despite being a “<em>plain old</em>” C program.
The algorithm and code can be improved in several ways (ordering the vertices, improving the pruning, using upper bounds from heuristic vertex coloring, using induced degree as in [2]), but still, the main loop and the backtrack machinery is all there, in a few lines of code!</p>

<p>Maybe you wonder about the efficiency of this code, but at the moment I have not a precise answer. For sure, the ordering of the vertices is crucial, and can make a huge difference on solving the <a href="http://iridia.ulb.ac.be/~fmascia/maximum_clique/DIMACS-benchmark">max-clique DIMACS instances</a>. I have used CBack to implement my own version of the Ostengard’s max-clique algorithm [4], but my implementation is somehow slower. I suspect that the difference is due to data structure used to store the graph (Ostengard’s implementation relies on bitsets), but not in the way the backtracking is achieved. Although, to answer to such question could be a subject of another post.</p>

<p>In conclusion, if you need to implement an exact enumerative algorithm, <a href="http://www.akira.ruc.dk/~keld/research/CBACK/">CBack</a> could be an option to consider.</p>

<h3 id="references">References</h3>

<ol>
  <li>
    <p>Keld Helsgaun. 
<span class="title">CBack: A Simple Tool for Backtrack Programming in C</span>. 
<span class="journal">Software: Practice and Experience</span>, 
vol. 25(8), pp. 905-934, 2006. 
<a href="http://dx.doi.org/10.1002/spe.4380250805">[doi]</a>
</p>
  </li>
  <li>
    <p>Carraghan and Pardalos. 
<span class="title">An exact algorithm for the maximum clique problem</span>. 
<span class="journal">Operations Research Letters</span>, 
vol. 9(6), pp. 375-382, 1990, 
<a href="http://www.dcs.gla.ac.uk/~pat/jchoco/clique/papersClique/carraghanPardalos90.pdf">[pdf]</a>
</p>
  </li>
  <li>
    <p>Torsten Fahle. 
<span class="title">Simple and Fast: Improving a Branch-and-Bound Algorithm</span>. 
In Proc <span class="journal">ESA 2002</span>, LNCS 2461, pp. 485-498.
<a href="http://dx.doi.org/10.1007/3-540-45749-6_44">[doi]</a>
</p>
  </li>
  <li>
    <p>Patric R.J. Ostergard.
<span class="title">A fast algorithm for the maximum clique problem</span>.
<span class="journal">Discrete Applied Mathematics</span>, 
vol. 120(1-3), pp. 197–207, 2002
<a href="http://citeseerx.ist.psu.edu/viewdoc/similar?doi=10.1.1.28.7666&amp;type=cc">[pdf]</a>
</p>
  </li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[From blackboard to code: Gomory Cuts using CPLEX]]></title>
    <link href="http://stegua.github.io/blog/2013/02/05/gomory-cuts-with-cplex/"/>
    <updated>2013-02-05T15:22:00+01:00</updated>
    <id>http://stegua.github.io/blog/2013/02/05/gomory-cuts-with-cplex</id>
    <content type="html"><![CDATA[<p><strong>Edited on May 16th, 2013</strong>: fixes due to <a href="http://imada.sdu.dk/~marco/">M. Chiarandini</a></p>

<p>On the blackboard, to solve small Integer Linear Programs with 2 variables and <em>less or equal</em> constraints is easy,
since they can be plotted in the plane and the linear relaxation can be solved geometrically. 
You can draw the lattice of integer points, and once you have found a new cutting plane, 
you show that it <em>cuts off</em> the optimum solution of the LP relaxation.</p>

<p>This post presents a naive (textbook) implementation of <strong>Fractional Gomory Cuts</strong> that uses the basic solution
computed by CPLEX, the commercial Linear Programming solver used in our lab sessions.
In practice, this post is an online supplement to one of my last exercise session.</p>

<p>In order to solve the <em>“blackboard”</em> examples with <a href="http://www-01.ibm.com/software/integration/optimization/cplex-optimizer/">CPLEX</a>,
it is necessary to use a couple of functions
that a few years ago were undocumented. <a href="http://www.gurobi.com">GUROBI</a> has very similar functions,
but they are currently undocumented. (<strong>Edited May 16th, 2013</strong>: From version 5.5, Gurobi has documented its 
<a href="http://www.gurobi.com/documentation/5.5/reference-manual/node109">advanced simplex routines</a>)</p>

<p>As usual, all the sources used to write this post are publicly available on 
<a href="https://github.com/stegua/MyBlogEntries/tree/master/GomoryCut">my GitHub repository</a>.</p>

<h3 id="the-basics">The basics</h3>
<p>Given a Integer Linear Program in the form:</p>

<script type="math/tex; mode=display">(P) \qquad \min \{ cx \mid Ax \leq b, \, x \geq 0, \, x \mbox{ integer} \}</script>

<p>it is possible to rewrite the problem in standard form by adding slack variables:</p>

<script type="math/tex; mode=display">(P) \qquad \min \{ cx \mid Ax + Ix_S = b, \, x \geq 0, \, x \mbox{ integer}, \, x_S \geq 0 \}</script>

<p>where <script type="math/tex">I</script> is the identity matrix and <script type="math/tex">x_S</script> is a vector of slack variables, one for each constraint in <script type="math/tex">(P)</script>.
Let us denote by <script type="math/tex">(\bar{P})</script> the linear relaxation of <script type="math/tex">(P)</script> obtained by relaxing the integrality constraint.</p>

<p>The optimum solution vector of <script type="math/tex">(\bar{P})</script>, if it exists and it is finite, it is used to derive a basis
(for a formal definition of <strong>basis</strong>, see [1] or [3]).
Indeed, the basis partitions the columns of matrix <script type="math/tex">A</script> into two submatrices
<script type="math/tex">B</script> and <script type="math/tex">N</script>, where <script type="math/tex">B</script> is given by the columns corresponding to the basic variables,
and <script type="math/tex">N</script> by columns corresponding to variables out of the base (they are equal to zero in the optimal solution vector).</p>

<p>Remember that, by definition, <script type="math/tex">B</script> is nonsingular and therefore is invertible. 
Using the matrices <script type="math/tex">B</script> and <script type="math/tex">N</script>, it is easy to derive the following inequalities (for details, see any OR textbook, e.g., [1]): </p>

<script type="math/tex; mode=display">% &lt;![CDATA[
\begin{eqnarray}
&Ax = b & \\
&Bx_B + Nx_N = b& \\
&x_B + B^{-1}N\,x_N = B^{-1}\,b & \qquad B \mbox{ is nonsingular} \\
&x_B + \lfloor B^{-1}N \rfloor \,x_N \leq B^{-1}\,b &\qquad  \mbox{since }x \geq 0 \\
&x_B + \lfloor B^{-1}N \rfloor \,x_N \leq \lfloor B^{-1}\,b \rfloor& \qquad x \mbox{ is integer}
\end{eqnarray} %]]&gt;</script>

<p>where the operator <script type="math/tex">\lfloor \cdot \rfloor</script> is applied component wise to the matrix elements.
In practice, for each fractional basic variable, it is possible to generate a valid Gomory cut.</p>

<p>The key step to generate Gomory cuts is to get an optimal basis or, even better, the inverse of the basis matrix <script type="math/tex">B^{-1}</script>
multiplied by <script type="math/tex">A</script> and by <script type="math/tex">b</script>. Once we have that matrix, in order to generate a Gomory cut from a fractional
basic variable, we just use the last equation in the previous derivation, applying it to each row of the system of inequalities</p>

<p>Given the optimal basis, the optimal basic vector is <script type="math/tex">x_B=B^{-1}b</script>, since the non basic variables are equal to zero.
Let <script type="math/tex">j</script> be the index of a fractional basic variable, and let <script type="math/tex">i</script> be the index of the constraint corresponding to
variable <script type="math/tex">j</script> in the equations <script type="math/tex">x_B=B^{-1}A</script>, then the Gomory cut for variable <script type="math/tex">j</script> is:</p>

<script type="math/tex; mode=display">x_j + \sum_{l \in N} \lfloor (B^{-1}N)_{il} \rfloor\,x_l \leq \lfloor (B^{-1}\,b)_i \rfloor</script>

<h3 id="using-the-cplex-callable-library">Using the CPLEX callable library</h3>
<p>The CPLEX callable library (written in C) has the following <em>advanced</em> functions:</p>

<ul>
  <li><a href="http://pic.dhe.ibm.com/infocenter/cosinfoc/v12r5/index.jsp?topic=%2Filog.odms.cplex.help%2Frefcallablelibrary%2Fhtml%2Ffunctions%2FCPXbinvarow.html">CPXbinvarow</a> computes the <em>i</em>-th row of the tableau</li>
  <li><a href="http://pic.dhe.ibm.com/infocenter/cosinfoc/v12r5/index.jsp?topic=%2Filog.odms.cplex.help%2Frefcallablelibrary%2Fhtml%2Ffunctions%2FCPXbinvrow.html">CPXbinvrow</a> computes the <em>i</em>-th row of the basis inverse</li>
  <li><a href="http://pic.dhe.ibm.com/infocenter/cosinfoc/v12r5/index.jsp?topic=%2Filog.odms.cplex.help%2Frefcallablelibrary%2Fhtml%2Ffunctions%2FCPXbinvacol.html">CPXbinvacol</a> computes the representation of the <em>j</em>-th column in terms of the basis</li>
  <li><a href="http://pic.dhe.ibm.com/infocenter/cosinfoc/v12r5/index.jsp?topic=%2Filog.odms.cplex.help%2Frefcallablelibrary%2Fhtml%2Ffunctions%2FCPXbinvcol.html">CPXbinvcol</a> computes the <em>j</em>-th column of the basis inverse</li>
</ul>

<p>Using the first two functions, Gomory cuts from an optimal base can be generated as follows:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>Gomory cut </span><a href="https://github.com/stegua/MyBlogEntries/blob/master/GomoryCut/cpx_gomory.c">Fork Me on GitHub</a></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span></span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">Generate Gomory cuts:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class="line"><span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line"><span class="n">cut</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">/// Index of cut to be added</span>
</span><span class="line"><span class="k">for</span> <span class="p">(</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span>
</span><span class="line"><span class="k">if</span> <span class="p">(</span> <span class="n">floor</span><span class="p">(</span><span class="n">b_bar</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">!=</span> <span class="n">b_bar</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">)</span> <span class="p">{</span>
</span><span class="line">   <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Row %d gives cut -&gt;   &quot;</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
</span><span class="line">   <span class="n">POST_CMD</span><span class="p">(</span> <span class="n">CPXbinvarow</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span> <span class="p">);</span>
</span><span class="line">   <span class="n">rmatbeg</span><span class="p">[</span><span class="n">cut</span><span class="p">]</span> <span class="o">=</span> <span class="n">idx</span><span class="p">;</span>
</span><span class="line">   <span class="k">for</span> <span class="p">(</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n1</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span> <span class="p">)</span> <span class="p">{</span>
</span><span class="line">      <span class="n">z</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">floor</span><span class="p">(</span><span class="n">z</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span> <span class="c1">/// DANGER!</span>
</span><span class="line">      <span class="k">if</span> <span class="p">(</span> <span class="n">z</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
</span><span class="line">         <span class="n">rmatind</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
</span><span class="line">         <span class="n">rmatval</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">z</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
</span><span class="line">         <span class="n">idx</span><span class="o">++</span><span class="p">;</span>
</span><span class="line">      <span class="p">}</span>
</span><span class="line">      <span class="c1">/// Print the cut</span>
</span><span class="line">      <span class="k">if</span> <span class="p">(</span> <span class="n">z</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="p">)</span> <span class="n">printf</span><span class="p">(</span><span class="s">&quot;+&quot;</span><span class="p">);</span>
</span><span class="line">      <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%.1f x%d &quot;</span><span class="p">,</span> <span class="n">z</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
</span><span class="line">   <span class="p">}</span>
</span><span class="line">   <span class="n">gc_rhs</span><span class="p">[</span><span class="n">cut</span><span class="p">]</span> <span class="o">=</span> <span class="n">floor</span><span class="p">(</span><span class="n">b_bar</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span> <span class="c1">/// DANGER!</span>
</span><span class="line">   <span class="n">gc_sense</span><span class="p">[</span><span class="n">cut</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;L&#39;</span><span class="p">;</span>
</span><span class="line">   <span class="n">printf</span><span class="p">(</span><span class="s">&quot;&lt;= %.1f</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">gc_rhs</span><span class="p">[</span><span class="n">cut</span><span class="p">]);</span>
</span><span class="line">   <span class="n">cut</span><span class="o">++</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line"><span class="c1">/// Add the new cuts</span>
</span><span class="line"><span class="n">POST_CMD</span><span class="p">(</span> <span class="n">CPXaddrows</span> <span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">n_cuts</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">gc_rhs</span><span class="p">,</span> <span class="n">gc_sense</span><span class="p">,</span>
</span><span class="line">         <span class="n">rmatbeg</span><span class="p">,</span> <span class="n">rmatind</span><span class="p">,</span> <span class="n">rmatval</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">);</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>The code reads row by row (index <em>i</em>) the inverse basis matrix <script type="math/tex">B^{-1}</script> multiplied by <script type="math/tex">A</script> (line 7),
which is temporally stored in vector <code>z</code>,
and then the code stores the corresponding Gomory cut in the compact matrix given by vectors <code>rmatbeg</code>, <code>rmatind</code>, and <code>rmatval</code> (lines 8-15).
The array <code>b_bar</code> contains the vector <script type="math/tex">B^{-1}b</script> (line 21). In lines 26-27, all the cuts are added at once to the current LP data structure.</p>

<p>On GitHub you find a small program that I wrote to generate Gomory cuts for problems written as <script type="math/tex">(P)</script>.
The repository have an <a href="https://github.com/stegua/MyBlogEntries/blob/master/GomoryCut/README.md">example of execution</a> of my program.</p>

<p>The code is simple only because it is designed for small IPs in the form
<script type="math/tex"> \min\, \{\, cx \mid Ax\, \leq\,b,\, x\geq 0\}</script>.
Otherwise, the code <strong>must</strong> consider the effects of preprocessing, different sense of the constraints,
and additional constraints introduced because of range constraints.</p>

<p>If you are interested in a <strong>real</strong> implementation of <strong>Mixed-Integer Gomory cuts</strong>, 
that are a generalization of Fractional Gomory cuts to <strong>mixed integer linear programs</strong>, 
please look at the <a href="http://scip.zib.de/doc/html/sepa__gomory_8h.shtml">SCIP source code</a>.</p>

<h3 id="additional-readings">Additional readings</h3>
<p>The introduction of Mixed Integer Gomory cuts 
in CPLEX was <strong>The</strong> major breakthrough of CPLEX 6.5 and produced
the version-to-version speed-up given by the blue bars in the chart below
(source: <a href="http://www.ferc.gov/eventcalendar/Files/20100609110044-Bixby,%20Gurobi%20Optimization.pdf">Bixby’s slides available on the web</a>):</p>

<p><img src="http://stegua.github.io/images/cplex65.png" /></p>

<p>Gomory cuts are still subject of research, since they pose a number of implementation challenges. 
These cuts suffer from severe numerical issues, mainly because the computation of the inverse matrix
requires the division by its determinant.</p>

<blockquote>
  <p>“In 1959, […] We started to experience the unpredictability of the computational results rather steadily” (Gomory, see [4]).”</p>
</blockquote>

<p>A recent paper by Cornuejols, Margot, and Nannicini deals with some of these issues [2].</p>

<p>If you like to learn more about how the basis are computed in the CPLEX LP solver, there is very nice paper
by Bixby [3]. The paper explains different approaches to get the first basic feasible solution and
gives some hints of the CPLEX implementation of that time, i.e., 1992. Though the paper does not deal with Gomory
cuts directly, it is a very pleasant reading.</p>

<p>To conclude, for those of you interested in <a href="http://www.math.uiuc.edu/documenta/vol-ismp/vol-ismp.html">Optimization Stories</a>
there is a nice chapter by G. Cornuejols about the <strong>Ongoing Story of Gomory Cuts</strong> [4].</p>

<h2 id="references">References</h2>
<ol>
  <li>
    <p>C.H. Papadimitriou, K. Steiglitz.
<span class="title">Combinatorial Optimization: Algorithms and Complexity</span>. 1998.
<a href="http://www.amazon.com/Combinatorial-Optimization-Algorithms-Complexity-Computer/dp/0486402584">[book]</a></p>
  </li>
  <li>
    <p>G. Cornuejols, F. Margot and G. Nannicini.
<span class="title">On the safety of Gomory cut generators</span>. Submitted in 2012.
<span class="journal">Mathematical Programming Computation, under review.</span> 
<a href="http://faculty.sutd.edu.sg/~nannicini/papers/testing_gomory.pdf">[preprint]</a></p>
  </li>
  <li>
    <p>R.E. Bixby.
<span class="title">Implementing the Simplex Method: The Initial Basis</span>.
<span class="journal">Journal on Computing</span> vol. 4(3), pages 267&#8211;284, 1992.
<a href="http://joc.journal.informs.org/content/4/3/267.short">[abstract]</a></p>
  </li>
  <li>
    <p>G. Cornuejols.
<span class="title">The Ongoing Story of Gomory Cuts</span>.
<span class="journal">Documenta Mathematica - Optimization Stories.</span> Pages 221-226, 2012.
<a href="http://www.math.uiuc.edu/documenta/vol-ismp/37_cornuejols-gerard.pdf">[preprint]</a></p>
  </li>
</ol>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How Italian Commuters Discovered Operations Research]]></title>
    <link href="http://stegua.github.io/blog/2012/12/16/how-italian-commuters-discovered-or/"/>
    <updated>2012-12-16T10:45:00+01:00</updated>
    <id>http://stegua.github.io/blog/2012/12/16/how-italian-commuters-discovered-or</id>
    <content type="html"><![CDATA[<p>Last week, more then 700,000 Italian commuters discovered the importance of Operations Research (OR).
Nobody explicitly mentioned OR, 
but due to a horrible crew schedule of <a href="http://www.trenord.it">Trenord</a> 
(a train operator with around 330 trains and 2700 employees),
the commuters had a <strong>long, long, long nightmare</strong>. 
During the whole week, several trains were cancelled (1375 in total) and most of the trains were delayed.
A <a href="http://milano.corriere.it/milano/notizie/cronaca/12_dicembre_11/treni-cronaca-caos-episodi-2113111724378.shtml">newspaper</a> wrote that a commuter waiting to go home had the painful record of 11 consecutive trains cancelled.
The Italian online edition of Wired has an <a href="http://daily.wired.it/news/tech/2012/12/13/trenord-treni-software-caos-85247.html">article about this horrible week</a>. 
If you want to get an idea of the chaos you can search for “caos tilt software trenord” on google.it.</p>

<p>Trenord officially said that the software that planned the crew schedule is faulty. 
The software was bought last year from <a href="http://www.goalsystems.com">Goal Systems</a>, a Spanish company.
Rumors say that Trenord paid the Goal System around <strong>1,500,000 Euro</strong>.
Likely, the system is not faulty, but it “<em>only</em>” had bad input data.</p>

<h2 id="what-newspapers-do-not-write">What newspapers do not write</h2>

<p>Before the Goal System, Trenord was using a different software, produced by
<a href="http://www.maior.it">Management Artificial Intelligence Operations Research srl (MAIOR)</a>
that is used by several public transportation companies in Italy,
included <a href="http://www.atm.it">ATM</a> that operates the subway and buses in Milan.
In addition, MAIOR collaborates with the <em>Politecnico di Milano</em> and the <em>University of Pisa</em>
to improve continuously its software.
Honestly, I am biased, since I collaborate with MAIOR. 
However, Trenord dismissed the software of MAOIR
without any specific complaint, since the management had decided to buy the Goal System software.</p>

<p>Newspapers do not ask the following question:</p>

<blockquote>
  <p>Why to change a piece of software, if the previous one was working correctly?</p>
</blockquote>

<p>In Italy, soccer players have a motto: “<em>squadra che vince non si cambia</em>”.
Maybe at Trenord nobody plays soccer.</p>

<h3 id="maior-is-back">MAIOR is back</h3>
<p>Likely, next week will be better for the 700,000 commuters,
since OR experts from MAIOR are traveling to Milan to 
help Trenord to improve the situation.</p>

<h3 id="disclaimer-post-edited-on-18th-december-2012">Disclaimer (post edited on 18th December 2012)</h3>
<ol>
  <li>I am a Pavia-Milano commuter disappointed of the chaotic week we had.</li>
  <li>The information reported in this post were obtained with searches on google.it and published on Italian online magazines.</li>
  <li>Surely, the Goal System is a piece of software as good as MAIOR software is.</li>
  <li>This post does not intend to offend anyone. </li>
</ol>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Challenging MIPs instances]]></title>
    <link href="http://stegua.github.io/blog/2012/12/13/challenging-mips/"/>
    <updated>2012-12-13T18:11:00+01:00</updated>
    <id>http://stegua.github.io/blog/2012/12/13/challenging-mips</id>
    <content type="html"><![CDATA[<p>Today, I share seven challenging MIP instances as 
<a href="http://en.wikipedia.org/wiki/MPS_%28format%29">.mps files</a>
along with the AMPL <a href="https://github.com/stegua/MyBlogEntries/tree/master/Roadef2012">model and data files</a> 
I used to generate them. 
While I like the <a href="http://miplib.zib.de/">MIPLIBs</a>, I do prefer problem libraries similar to the 
<a href="http://www.csplib.org/">CSPLIB</a> where
you get both a problem description <strong>and</strong> a set of data. This allows anyone to try
with her new model and/or method.</p>

<p>The MIP instances I propose come from my formulation of
the <a href="http://challenge.roadef.org/2012/en/sujet.php">Machine Reassignment Problem</a> 
proposed for the <a href="http://roadef.org/content/index.htm">Roadef Challenge</a> sponsored by Google last year. 
As I wrote in a <a href="http://stegua.github.io/blog/2012/10/19/cp2012-je-me-souviens/">previous post</a>, 
the Challenge had <strong>huge</strong> instances and a <em>micro</em> time limit of 300 seconds.
I said <em>micro</em> because I have in mind exact methods: there is little you can do in 300 seconds when you
have a problem with potentially as many as <script type="math/tex">50000 \times 5000</script> binary variables. 
If you want to use math programming and start with the solution of a linear programming relaxation of the problem,
you have to be careful: it might happen that you cannot even solve the LP relaxation at the root node within 300 seconds.</p>

<p>That is why most of the participants tackled the Challenge mainly with heuristic algorithms.
The only <em>general purpose</em> solver that qualified for the challenge is <a href="http://www.localsolver.com">Local Solver</a>,
which has a nice abstraction (“somehow” similar to AMPL) to well-known local search algorithms and move operators.
The Local Solver script used in the qualification phase is available 
<a href="http://www.localsolver.com/misc/google_machine_reassignment.lsp">here</a>.</p>

<p>However, in my own opinion, it is interesting to try to solve at least the instances of the qualification phase
with Integer Linear Programming (ILP) solvers such as 
<a href="http://www.gurobi.com">Gurobi</a> and <a href="http://www-01.ibm.com/software/integration/optimization/cplex-optimizer/">CPLEX</a>.
Can these branch-and-cut commercial solvers be competitive on such problems? </p>

<h2 id="problem-overview">Problem Overview</h2>

<p>Consider you are given a set of processes <script type="math/tex">P</script>, a set of machines <script type="math/tex">M</script>,
and an initial mapping <script type="math/tex">\pi</script> of each process to a single machine 
(i.e., <script type="math/tex">\pi_p = i</script> if process <script type="math/tex">p</script> is initially assigned to machine <script type="math/tex">i</script>).
Each process consumes several <em>resources</em>, e.g., CPU, memory, and bandwidth.
In the challenge, some processes were defined to be
<em>transient</em>: they consume resources both on the machine where they are initially located,
and in the machine they are going to be after the reassignment.
The problem asks to find a new assignment of processes to machines that minimizes a rather involved cost function.</p>

<p>A basic ILP model will have a 0-1 variable <script type="math/tex">x_{pi}</script> equals to 1 if you
(re)assign process <script type="math/tex">p</script> to machine <script type="math/tex">i</script>. The number of processes and the number of machines give
a first clue on the size of the problem. 
The constraints on the resource capacities yield a multi-dimensional knapsack subproblem for each machine.
The Machine Reassignment Problem has other constraints (kind of logical 0-1 constraints), 
but I do not want to bore you here with a full problem description. 
If you like to see my model, please read the 
<a href="https://github.com/stegua/MyBlogEntries/blob/master/Roadef2012/ampl-scripts/roadef2012.mod">AMPL model file</a>. </p>

<h2 id="a-first-attempt-with-gurobi">A first attempt with Gurobi</h2>
<p>In order to convince you that the proposed instances are challenging, I report some computational results.</p>

<p>The table below reports for each instance the best result obtained by the participants
of the challenge (second column). The remaining four columns give 
the upper bound (UB), the lower bound (LB), the number of branch-and-bound nodes, and the computation time in seconds
obtained with Gurobi 5.0.1, a timeout of 300 seconds, and the default parameter setting on a rather old desktop
(single core, 2Gb of RAM).</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">Instance</th>
      <th style="text-align: right">Best Known UB</th>
      <th style="text-align: right">Upper Bound</th>
      <th style="text-align: right">Lower Bound</th>
      <th style="text-align: right">Nodes</th>
      <th style="text-align: right">Time</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">a1-1</td>
      <td style="text-align: right">44,306,501</td>
      <td style="text-align: right"><strong>44,306,501</strong></td>
      <td style="text-align: right"><strong>44,306,501</strong></td>
      <td style="text-align: right">0</td>
      <td style="text-align: right">0.05</td>
    </tr>
    <tr>
      <td style="text-align: center">a1-2</td>
      <td style="text-align: right">777,532,896</td>
      <td style="text-align: right">780,511,277</td>
      <td style="text-align: right">777,530,829</td>
      <td style="text-align: right">537</td>
      <td style="text-align: right">-</td>
    </tr>
    <tr>
      <td style="text-align: center">a1-3</td>
      <td style="text-align: right">583,005,717</td>
      <td style="text-align: right"><strong>583,005,720</strong></td>
      <td style="text-align: right"><strong>583,005,715</strong></td>
      <td style="text-align: right">15</td>
      <td style="text-align: right">48.76</td>
    </tr>
    <tr>
      <td style="text-align: center">a1-4</td>
      <td style="text-align: right">252,728,589</td>
      <td style="text-align: right">320,104,617</td>
      <td style="text-align: right">242,404,632</td>
      <td style="text-align: right">24</td>
      <td style="text-align: right">-</td>
    </tr>
    <tr>
      <td style="text-align: center">a1-5</td>
      <td style="text-align: right">727,578,309</td>
      <td style="text-align: right"><strong>727,578,316</strong></td>
      <td style="text-align: right"><strong>727,578,296</strong></td>
      <td style="text-align: right">221</td>
      <td style="text-align: right">2.43</td>
    </tr>
    <tr>
      <td style="text-align: center">a2-1</td>
      <td style="text-align: right">198</td>
      <td style="text-align: right">54,350,836</td>
      <td style="text-align: right">110</td>
      <td style="text-align: right">0</td>
      <td style="text-align: right">-</td>
    </tr>
    <tr>
      <td style="text-align: center">a2-2</td>
      <td style="text-align: right">816,523,983</td>
      <td style="text-align: right">1,876,768,120</td>
      <td style="text-align: right">559,888,659</td>
      <td style="text-align: right">0</td>
      <td style="text-align: right">-</td>
    </tr>
    <tr>
      <td style="text-align: center">a2-3</td>
      <td style="text-align: right">1,306,868,761</td>
      <td style="text-align: right">2,272,487,840</td>
      <td style="text-align: right">1,007,955,933</td>
      <td style="text-align: right">0</td>
      <td style="text-align: right">-</td>
    </tr>
    <tr>
      <td style="text-align: center">a2-4</td>
      <td style="text-align: right">1,681,353,943</td>
      <td style="text-align: right">3,223,516,130</td>
      <td style="text-align: right">1,680,231,407</td>
      <td style="text-align: right">0</td>
      <td style="text-align: right">-</td>
    </tr>
    <tr>
      <td style="text-align: center">a2-5</td>
      <td style="text-align: right">336,170,182</td>
      <td style="text-align: right">787,355,300</td>
      <td style="text-align: right">307,041,984</td>
      <td style="text-align: right">0</td>
      <td style="text-align: right">-</td>
    </tr>
  </tbody>
</table>

<p><br />
Instances <strong>a1-1</strong>, <strong>a1-3</strong>, <strong>a1-5</strong> are solved to optimality within 300 seconds
and hence they are not further considered.</p>

<p>The remaining seven instances are the challenging instances mentioned at the begging of this post.
The instances <strong>a2-x</strong> are embarrassing: they have an UB that is far away from both the best known UB
and the computed LB.
Specifically, look at the instance <strong>a2-1</strong>: the best result of the challenge has value 198, Gurobi
(using my model) finds a solution with cost 54,350,836: you may agree that this is “<em>slightly</em>” more than 198.
At the same time the LB is only 110. </p>

<p>Note that for all the <strong>a2-x</strong> instances the number of branch-and-bound nodes is zero.
After 300 seconds the solver is still at the root node trying to generate cutting planes and/or
running their primal heuristics. Using CPLEX 12.5 we got pretty similar results.</p>

<p>This is why I think these instances are challenging for branch-and-cut solvers. </p>

<h2 id="search-strategies-feasibility-vs-optimality">Search Strategies: Feasibility vs Optimality</h2>
<p>Commercial solvers have usually a meta-parameter that controls the search focus by setting other parameters
(how they are precisely set is undocumented: do you know more about?).
The two basic options of this parameter are (1) to focus on looking for feasible solution
or (2) to focus on proving optimality.
The name of this parameter is <strong>MipEmphasis</strong> in CPLEX and <strong>MipFocus</strong> in Gurobi. 
Since the LPs are quite time consuming and after 300 seconds the solver is still at the root node, 
we can wonder whether generating cuts is of any help on these instances.</p>

<p>If we set the MipFocus to <strong>feasibility</strong> and we explicitly <strong>disable all cut generators</strong>, would we get better results?</p>

<p>Look at the table below:
the values of the upper bounds of instances <strong>a1-2</strong>, <strong>a1-4</strong>, and <strong>a2-3</strong> are slightly better than before: 
this is a good news. However, for instance <strong>a2-1</strong> the upper bound is worse, and for the other three instances there is no difference. Moreover, the LBs are always weaker: as expected, there is no free lunch!</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">Instance</th>
      <th style="text-align: right">Upper Bound</th>
      <th style="text-align: right">Lower Bound</th>
      <th style="text-align: right">Gap</th>
      <th style="text-align: right">Nodes</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">a1-2</td>
      <td style="text-align: right">779,876,897</td>
      <td style="text-align: right">777,530,808</td>
      <td style="text-align: right">0.30%</td>
      <td style="text-align: right">324</td>
    </tr>
    <tr>
      <td style="text-align: center">a1-4</td>
      <td style="text-align: right">317,802,133</td>
      <td style="text-align: right">242,398,325</td>
      <td style="text-align: right">23.72%</td>
      <td style="text-align: right">48</td>
    </tr>
    <tr>
      <td style="text-align: center">a2-1</td>
      <td style="text-align: right">65,866,574</td>
      <td style="text-align: right">66</td>
      <td style="text-align: right">99.99%</td>
      <td style="text-align: right">81</td>
    </tr>
    <tr>
      <td style="text-align: center">a2-2</td>
      <td style="text-align: right">1,876,768,120</td>
      <td style="text-align: right">505,443,999</td>
      <td style="text-align: right">73.06%</td>
      <td style="text-align: right">0</td>
    </tr>
    <tr>
      <td style="text-align: center">a2-3</td>
      <td style="text-align: right">1,428,873,892</td>
      <td style="text-align: right">1,007,955,933</td>
      <td style="text-align: right">29.45%</td>
      <td style="text-align: right">0</td>
    </tr>
    <tr>
      <td style="text-align: center">a2-4</td>
      <td style="text-align: right">3,223,516,130</td>
      <td style="text-align: right">1,680,230,915</td>
      <td style="text-align: right">47.87%</td>
      <td style="text-align: right">0</td>
    </tr>
    <tr>
      <td style="text-align: center">a2-5</td>
      <td style="text-align: right">787,355,300</td>
      <td style="text-align: right">307,040,989</td>
      <td style="text-align: right">61.00%</td>
      <td style="text-align: right">0</td>
    </tr>
  </tbody>
</table>

<p><br />
If we want to keep a timeout of 300 seconds, there is little we can do, unless we develop an ad-hoc decomposition approach.</p>

<blockquote>
  <p>Can we improve those results with a branch-and-cut solver using a longer timeout?</p>
</blockquote>

<p>Most of the papers that uses branch-and-cut to solve hard problems have a timeout
of at least one hour, and they start by running an heuristic for around 5 minutes.
Therefore, we can think of using the best results obtained by the participants of the 
challenge as starting solution. </p>

<p>So, let us make a step backward: we enable all cut generators and we set all parameters at the default value.
In addition we set the time limit to one hour. The table below gives the new results.
With this setting we are able to “prove” near-optimality of instance <strong>a1-2</strong>, and we reduce
significantly the gap of instance <strong>a2-4</strong>.
However, the solver never improves the primal solutions: this means that we have not improved the results
obtained in the qualification phase of the challenge.
Note also that the number of nodes explored is still rather small despite the longer timeout.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">Instance</th>
      <th style="text-align: right">Upper Bound</th>
      <th style="text-align: right">Lower Bound</th>
      <th style="text-align: right">Gap</th>
      <th style="text-align: right">Nodes</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">a1-2</td>
      <td style="text-align: right">777,532,896</td>
      <td style="text-align: right">777,530,807</td>
      <td style="text-align: right">~0.001%</td>
      <td style="text-align: right">0</td>
    </tr>
    <tr>
      <td style="text-align: center">a1-4</td>
      <td style="text-align: right">252,728,589</td>
      <td style="text-align: right">242,404,642</td>
      <td style="text-align: right">4.09%</td>
      <td style="text-align: right">427</td>
    </tr>
    <tr>
      <td style="text-align: center">a2-1</td>
      <td style="text-align: right">198</td>
      <td style="text-align: right">120</td>
      <td style="text-align: right">39.39%</td>
      <td style="text-align: right">2113</td>
    </tr>
    <tr>
      <td style="text-align: center">a2-2</td>
      <td style="text-align: right">816,523,983</td>
      <td style="text-align: right">572,213,976</td>
      <td style="text-align: right">29.92%</td>
      <td style="text-align: right">18</td>
    </tr>
    <tr>
      <td style="text-align: center">a2-3</td>
      <td style="text-align: right">1,306,868,761</td>
      <td style="text-align: right">1,068,028,987</td>
      <td style="text-align: right">18.27%</td>
      <td style="text-align: right">69</td>
    </tr>
    <tr>
      <td style="text-align: center">a2-4</td>
      <td style="text-align: right">1,681,353,943</td>
      <td style="text-align: right">1,680,231,594</td>
      <td style="text-align: right">0.06%</td>
      <td style="text-align: right">133</td>
    </tr>
    <tr>
      <td style="text-align: center">a2-5</td>
      <td style="text-align: right">336,170,182</td>
      <td style="text-align: right">307,042,542</td>
      <td style="text-align: right">8.66%</td>
      <td style="text-align: right">187</td>
    </tr>
  </tbody>
</table>

<p><br />
What if we disable all cuts and set the <strong>MipFocus</strong> to feasibility again?</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">Instance</th>
      <th style="text-align: right">Upper Bound</th>
      <th style="text-align: right">Lower Bound</th>
      <th style="text-align: right">Gap</th>
      <th style="text-align: right">Nodes</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">a1-2</td>
      <td style="text-align: right">777,532,896</td>
      <td style="text-align: right">777,530,807</td>
      <td style="text-align: right">~0.001%</td>
      <td style="text-align: right">0</td>
    </tr>
    <tr>
      <td style="text-align: center">a1-4</td>
      <td style="text-align: right">252,728,589</td>
      <td style="text-align: right">242,398,708</td>
      <td style="text-align: right">4.09%</td>
      <td style="text-align: right">1359</td>
    </tr>
    <tr>
      <td style="text-align: center">a2-1</td>
      <td style="text-align: right"><strong>196</strong></td>
      <td style="text-align: right">70</td>
      <td style="text-align: right">64.28%</td>
      <td style="text-align: right">818</td>
    </tr>
    <tr>
      <td style="text-align: center">a2-2</td>
      <td style="text-align: right">816,523,983</td>
      <td style="text-align: right">505,467,074</td>
      <td style="text-align: right">38.09%</td>
      <td style="text-align: right">81</td>
    </tr>
    <tr>
      <td style="text-align: center">a2-3</td>
      <td style="text-align: right"><strong>1,303,662,728</strong></td>
      <td style="text-align: right">1,008,286,290</td>
      <td style="text-align: right">22.66%</td>
      <td style="text-align: right">56</td>
    </tr>
    <tr>
      <td style="text-align: center">a2-4</td>
      <td style="text-align: right">1,681,353,943</td>
      <td style="text-align: right">1,680,230,918</td>
      <td style="text-align: right">0.07%</td>
      <td style="text-align: right">108</td>
    </tr>
    <tr>
      <td style="text-align: center">a2-5</td>
      <td style="text-align: right"><strong>336,158,091</strong></td>
      <td style="text-align: right">307,040,989</td>
      <td style="text-align: right">8.67%</td>
      <td style="text-align: right">135</td>
    </tr>
  </tbody>
</table>

<p><br />
With this parameter setting, we improve the UB for 3 instances: <strong>a2-1</strong>, <strong>a2-3</strong>, and <strong>a2-5</strong>.
However, the lower bounds are again much weaker. Look at instance <strong>a2-1</strong>: the lower bound is
now 70 while before it was 120. If you look at instance <strong>a2-3</strong> you can see that even if
we got a better primal solution, the gap is weaker, since the lower bound is worse.</p>

<h2 id="rfc-any-idea">RFC: Any idea?</h2>
<p>With the focus on feasibility you get better results, but you might miss the ability to prove optimality.
With the focus on optimality you get better lower bounds, but you might not improve the primal bounds.</p>

<blockquote>
  <p>1) How to balance feasibility with optimality?</p>
</blockquote>

<p>To use branch-and-cut solver and to disable cut generators is counterintuitive, but if you do you, you get better
primal bounds.  </p>

<blockquote>
  <p>2) Why should I use a branch-and-cut solver then? </p>
</blockquote>

<p>Do you have any idea out there?</p>

<h3 id="minor-remark">Minor Remark</h3>
<p>While writing this post, we got 3 solutions that are better than those obtained by the participants of 
the qualification phase: 
<a href="https://github.com/stegua/MyBlogEntries/blob/master/Roadef2012/certificates/sol_a2_1.sol">a2-1</a>, 
<a href="https://github.com/stegua/MyBlogEntries/blob/master/Roadef2012/certificates/sol_a2_3.sol">a2-3</a>, and 
<a href="https://github.com/stegua/MyBlogEntries/blob/master/Roadef2012/certificates/sol_a2_5.sol">a2-5</a>
(the three links give the certificates of the solutions). 
We are almost there in proving optimality of <strong>a2-3</strong>, and we get better lower bounds than those 
<a href="http://4c.ucc.ie/~hsimonis/reassignment.pdf">published</a> in [1].</p>

<h2 id="references">References</h2>
<style type="text/css">
table { width:100%; }
thead {
   background-color: rgba(0,0,255,0.3);
   color: black;
   text-indent: 14px;
   text-align: left;
}
td { padding:4px; }
tbody tr:nth-child(odd) { background-color: rgba(0, 0, 100, 0.2);  }
tbody tr:nth-child(even) { background-color: rgba(0, 0, 100, 0.1); }
.title { color: #07235F; }
.journal { font-style: italic; }
</style>

<ol>
  <li>
    <p> Deepak Mehta, Barry O’Sullivan, Helmut Simonis. 
<span class="title">Comparing Solution Methods for the Machine Reassignment Problem</span>. 
In Proc of CP 2012, Québec City, Canada, October 8-12, 2012.
</p>
  </li>
</ol>

<h1 id="credits">Credits</h1>
<p>Thanks to <a href="https://plus.google.com/116327072470709585073/posts">Stefano Coniglio</a> 
and to <a href="http://imada.sdu.dk/~marco/">Marco Chiarandini</a> for their passionate discussions about the posts
in this blog. </p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CP2012: Je me souviens]]></title>
    <link href="http://stegua.github.io/blog/2012/10/19/cp2012-je-me-souviens/"/>
    <updated>2012-10-19T13:24:00+02:00</updated>
    <id>http://stegua.github.io/blog/2012/10/19/cp2012-je-me-souviens</id>
    <content type="html"><![CDATA[<p>Last week in Quebec City, there was the 
<a href="http://www.cp2012.org/">18th International Conference on Principles and Practice of Constraint Programming</a>.
This year the conference had a record of submissions (186 in total) and the program committee
made a vey nice job in organizing the plenary sessions and the tutorials.
You can find <a href="http://4c.ucc.ie/~hsimonis/CP2012/index.htm">very nice pictures</a> of the conference on <a href="http://4c.ucc.ie/~hsimonis/">Helmut’s web page</a>.</p>

<p>During the conference, the weather outside was pretty cold, but at the conference site
the discussions were warm and the presentations were intriguing.</p>

<p>In this post, I share an informal report of the conference as <a href="http://en.wikipedia.org/wiki/Je_me_souviens"><em>“Je me souviens”</em></a>. </p>

<h3 id="challenges-in-smart-grids">Challenges in Smart Grids</h3>
<p>The invited talks were excellent and my favorite one was given by Miguel F. Anjos
on Optimization Challenges in Smart Grid Operations.
Miguel is not exactly a CP programmer, he is more on discrete non linear 
optimization, but his talk was a perfect mixed of applications, modeling, and solution techniques.
Please, read and enjoy <a href="http://www.cp2012.org/slides/Anjos-OptChalSmartGrids-CP2012.pdf">his slides</a>.</p>

<p>I like to mention just one of his observations. Nowadays, electric cars are becoming more and more
present. What would happen when each of us will have an electric car?
Likely, during the night, while sleeping, we will connect our car to the grid to recharge the
car batteries. This will lead to high variability in night peaks of energy demand.</p>

<p>How to manage these peaks?</p>

<p>Well, what Miguel has reported as a possible challenging option is to think of the collection of cars connected to the grid as a kind of huge battery. This sort of <em>collective</em> battery could be used to better handle the peaks of energy demands. Each car would play the game with a double role: if there is not an energy demand peak, you can recharge the car battery; otherwise, the car battery could be used as a power source and it could supply energy to the grid. This is an oversimplification, but as you can image there would be great challenges and opportunities for any <em>constraint optimizer</em> in terms of modeling and solution techniques. </p>

<p>I am curious to read more about, do you?</p>

<h3 id="sessions-and-talks">Sessions and Talks</h3>
<p>This year CP had the thicker conference proceedings, ever. Traditionally, the papers are presented in two parallel sessions. Two is not that much when you think that this year at <a href="http://ismp2012.mathopt.org/">ISMP</a> there were 40 parallel sessions…
but still, you always regret that you could not attend the talk in the other session. Argh!</p>

<p>Here I like to mention just two works. However, the program chair is trying 
to make <a href="http://www.cp2012.org/accepted_papers.php">all the slides</a> available.
Have a look at the program and at the slides: there are many good papers.</p>

<p>In the application track, Deepak Mehta gave a nice talk about a joint work with Barry O’Sullivan and Helmut Simonis
on <a href="http://4c.ucc.ie/~hsimonis/reassignment.pdf"><em>Comparing Solution Methods for the Machine Reassignment Problem</em></a>, a problem
that Google has to solve every day in its 
<a href="http://www.google.com/about/datacenters/gallery/#/tech">data centers</a> and that was the subject of the <a href="http://challenge.roadef.org/2012/en/sujet.php">Google/Roadef Challenge 2012</a>.
The true challenge is given by the HUGE size of the instances and the very short timeout (300 seconds). The work presented by Deepak is really interesting and they got excellent results using CP-based Large Neighborhood Search: they classified second at the challenge.</p>

<p>Related to the <strong>Machine Reassignment Problem</strong> there was a second interesting talk entitled 
<em><a href="http://www.springerlink.com/content/52j3197311333658/">Weibull-based Benchmarks for Bin Packing</a></em>, 
by Ignacio Castineiras, Milan De Cauwer and Barry O’Sullivan. 
They have designed a parametric instance generator for bin packing problems based on the Weibull distribution.
Having a parametric generator is crucial to perform exhaustive computational results and to
identify those instances that are challenging for a particular solution technique.
For instance, they have considered a CP-approach to bin packing problems and they have identified those Weibull shape values that yield challenging instances for such an approach.
A nice feature is that their generator is able to create instances similar to those of the Google challenge…
I hope they will release their generator soon!</p>

<h3 id="the-doctoral-program">The Doctoral Program</h3>
<p>Differently from other conferences (as for instance <a href="http://ipco2013.dim.uchile.cl/">IPCO</a>), CP gives PhD
students the opportunity to present their ongoing work within a <a href="http://zivny.cz/dp12/">Doctoral Program</a>.
The sponsors cover part of the costs for attending the conference.
During the conference each student has a mentor who is supposed to
help him. This year there were around 24 students and only very few of them
had a paper accepted at the main conference. This means that without
the Doctoral Program, most of these students would not had the opportunity to attend the conference.</p>

<p>Geoffrey Chu awarded the 2012 ACP Doctoral Research Award for his thesis
<strong><em>Improving Combinatorial Optimization</em></strong>. To give you an idea about the amount of his contributions, consider that after his thesis presentation, someone in the audience asked:</p>

<p><em>“And you got only <strong>one PhD</strong> for all this work?”</em></p>

<p><em>Chapeau!</em> Among other things, Chu has implemented <a href="http://www.g12.csse.unimelb.edu.au/minizinc/challenge2011/description_chuffed.txt">Chuffed</a> one of the most efficient CP solver
that uses <em>lazy clause generation</em> and that ranked very well at the last
<a href="http://www.g12.cs.mu.oz.au/minizinc/challenge2012/results2012.html">MiniZinc Challenge</a>, even if it was not one of the official competitors. </p>

<p>For the record, the winner of the MiniZinc challenge of this year is (again) the <a href="http://www.gecode.org">Gecode team</a>. Congratulations!</p>

<h3 id="next-year">Next Year</h3>
<p>Next year CP will be held in Sweden, at Uppsala University on 16-20 September 2013.
Will you be there? I hope so…</p>

<p>In the meantime, if you were at the conference, which was your favorite talk and/or paper?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Dijkstra, Dantzig, and Shortest Paths]]></title>
    <link href="http://stegua.github.io/blog/2012/09/19/dijkstra/"/>
    <updated>2012-09-19T22:14:00+02:00</updated>
    <id>http://stegua.github.io/blog/2012/09/19/dijkstra</id>
    <content type="html"><![CDATA[<style type="text/css">
table { width:100%; }
thead {
   background-color: rgba(0,0,255,0.3);
   color: black;
   text-indent: 14px;
   text-align: left;
}
td { padding:4px; }
tbody tr:nth-child(odd) { background-color: rgba(0, 0, 100, 0.2);  }
tbody tr:nth-child(even) { background-color: rgba(0, 0, 100, 0.1); }
.title { color: #07235F; }
.journal { font-style: italic; }
</style>

<p>Here we go, my first blog entry, ever. Let’s start with two short quizzes.</p>

<p><strong>1. The well known Dijkstra’s algorithm is:</strong><br />
[a]  A greedy algorithm<br />
[b]  A dynamic programming algorithm<br />
[c]  A primal-dual algorithm<br />
[d]  It was discovered by Dantzig  </p>

<p><strong>2. Which is the best C++ implementation of Dijkstra’s algorithm among the following?</strong><br />
[a] The <a href="http://www.boost.org/doc/libs/1_51_0/libs/graph/doc/index.html">Boost Graph Library (BGL)</a><br />
[b] The <a href="http://lemon.cs.elte.hu/trac/lemon">COIN-OR Lemon Graph Library</a><br />
[c] The <a href="http://code.google.com/p/or-tools/">Google OrTools</a><br />
[d] Hei dude! We can do better!!!  </p>

<p>What is your answer for the first question? … well, the answers are all correct!
And for the second question? To know the correct answer, sorry, you have to read this post to the end…</p>

<p>If you are curious to learn more about the <em>classification</em> of the Dijkstra’s algorithm proposed in the first three answers,
please consider reading [1] and [2]. Honestly, I did not know that the algorithm was independently discovered by Dantzig [3] as a special
case of Linear Programming. 
However, Dantzig is credited for the first version of the bidirectional 
Dijkstra’s algorithm (should we called it <strong>Dantzig’s algorithm</strong>?), which is nowadays the best performing
algorithm on general graphs.
The bidirectional Dijkstra’s algorithm is used as benchmark to measure the speed-up of modern specialized
shortest path algorithms for road networks [4,5], those algorithms that are implemented, for instance, in our
GPS navigation systems, in yours smartphones (I don’t have one, argh!), in Google Maps Directions, and Microsoft Bing Maps. </p>

<p>Why a first blog entry on Dijkstra’s algorithm? That’s simple.</p>

<ul>
  <li>Have you ever implemented an <em>efficient</em> version of this well-known and widely studied algorithm?</li>
  <li>Have you ever used the version that is implemented in well-reputed graph libraries, such as, the 
<a href="http://www.boost.org/doc/libs/1_51_0/libs/graph/doc/index.html">Boost Graph Library (BGL)</a>, 
the <a href="http://lemon.cs.elte.hu/trac/lemon">COIN-OR Lemon</a>, and/or 
<a href="http://code.google.com/p/or-tools/">Google OrTools</a>?</li>
</ul>

<p>I did while programming in C++, and I want to share with you my experience.</p>

<h2 id="the-algorithm">The Algorithm</h2>

<p>The algorithm is quite simple. First partition the nodes of the input graph <em>G=(N,A)</em> in three
sets: the sets of (1) <em>scanned</em>, (2) <em>reachable</em>, and (3) <em>unvisited</em> nodes.
Every node has a distance label <script type="math/tex">d_i</script> and a predecessor vertex <script type="math/tex">p_i</script>. Initially, set the 
label of the source node <script type="math/tex">d_s=0</script>, while set <script type="math/tex">d_i=+\infty</script> for all other nodes. Moreover,
the node <em>s</em> is placed in the set of <em>reachable</em> nodes, while all the other nodes are <em>unvisited</em>.</p>

<p>The algorithm proceedes as follows: select a <em>reachable</em> node <em>i</em> with minimum distance label,
and move it in the set of <em>scanned</em> nodes, it will be never selected again. 
For each arc <em>(i,j)</em> in the forward star of node <em>i</em> check if node <em>j</em> has distance label <script type="math/tex">d_j > d_i + c_{ij}</script>; 
if it is the case, update the label <script type="math/tex">d_j = d_i + c_{ij}</script> and the predecessor vertex <script type="math/tex">p_j=i</script>.
In addition, if the node was <em>unvisited</em>, move it in the 
set of reachable nodes. If the selected node <em>i</em> is the destination node
<em>t</em>, stop the algorithm.
Otherwise, continue by selecting the next node <em>i</em> with minimum distance label.</p>

<p>The algorithm stops either when it scans the destination node <em>t</em> or the set of reachable nodes is empty.
For the nice properties of the algorithm consult any textbook in computer science or operations research. </p>

<p>At this point it should be clear why Dijkstra’s algorithm is <strong>greedy</strong>: it always select a reachable node with
minimum distance label. It is a <strong>dynamic programming</strong> algorithm because it maintains the 
recursive relation 
<script type="math/tex">d_j = \min \{d_i + c_{ij} \mid (i,j) \in A \}</script> 
for all <script type="math/tex">j \in N</script>.
If you are familiar with Linear Programming, you should recognize that the distance labels
play the role of dual variable of a flow based formulation of the shortest path problem,
and the Dijkstra’s algorithm costructs a <strong>primal</strong> solution (i.e. a path) that satisfies the <strong>dual</strong>
constraints <script type="math/tex">d_j - d_i \leq c_{ij}</script>.</p>

<h2 id="graphs-and-heaps">Graphs and Heaps</h2>

<p>The algorithm uses two data structures: the input graph <em>G</em> and the set of reachable nodes <em>Q</em>.
The graph <em>G</em> can be stored with an adjacency list, but be sure that the arcs are stored in contiguous memory,
in order to reduce the chance of cache misses when scanning the forward stars. In my implementation, I have used
a std::vector to store the forward star of each node.</p>

<p>The second data structure, the most important, is the priority queue <em>Q</em>.
The queue has to support three operations: <em>push</em>, <em>update</em>, and <em>extract-min</em>.
The type of priority queue used determines the worst-case complexity of the Dijkstra’s algorithm.
Theoretically, the best strongly polynomial worst-case complexity is achieved via a <strong>Fibonacci heap</strong>. 
On road networks, the Multi Bucket heap yields a weakly polynomial worst-case complexity that
is more efficient in practice [4,5]. Unfortunately, the Fibonacci Heap is a rather complex data structure,
and lazy implementations end up in using a simpler Binomial Heap.</p>

<p>The good news is that the Boost Library from version 1.49 has a <a href="http://www.boost.org/doc/libs/1_51_0/doc/html/heap.html">Heap library</a>.
This library contains several type of heaps that share a common interface: 
d-ary-heap, binomial-heap, fibonacci-heap, pairing-heap, and skew-heap.
The worst-case complexity of the basic operations are summarized in a
<a href="http://www.boost.org/doc/libs/1_51_0/doc/html/heap/data_structures.html#heap.data_structures.data_structure_configuration">nice table</a>. 
Contrary to text-books, these heaps are ordered in non increasing order (they are max-heap instead of min-heap), that means
that the top of the heap is always the element with highest priority. For implementing Dijkstra,
where all arc lengths are non negative, this is not a problem: we can store the elements with
the distance changed in sign (sorry for the rough explanation, but if you are <em>really</em> intrested it is better to read directly the source code).</p>

<p>The big advantage of <strong>boost::heap</strong> is that it allows to program Dijkstra once, and to compile it
with different heaps via templates. If you wonder why the Boost Graph Library does not use boost::heap,
well, the reason is that BGL was implemented a few years ago, while boost::heap appeared this year.</p>

<h2 id="benchmarking-on-road-networks">Benchmarking on Road Networks</h2>
<p>Here is the point that maybe interests you the most: can we do better than well-reputed C++ graph libraries?</p>

<p>I have tried three graph libraries: 
<a href="http://www.boost.org/doc/libs/1_51_0/libs/graph/doc/index.html">Boost Graph Library (BGL)</a> v1.51, 
<a href="http://lemon.cs.elte.hu/trac/lemon">COIN-OR Lemon</a> v1.2.3, and 
<a href="http://code.google.com/p/or-tools/">Google OrTools</a> cheked out from svn on Sep 7th, 2012.
They all have a Dijkstra implementation, even if I don’t know the implementation details.
As a plus, the three libraries have python wrappers (but I have not test it).
The BGL is a header only library. Lemon came after BGL.
BGL, Lemon, and my implementation use (different) Fibonacci Heaps, while I have not clear what type of priority queue is used by OrTools.</p>

<p><strong>Disclaimer</strong>: Google OrTools is much more than a graph library: among others, it has a Constraint Programming solver with very nice
features for Large Neighborhood Search; however, we are interested here only in its Dijkstra implementation.
Constraint Programming will be the subject of another future post.</p>

<p>A few tests on instances taken from the last <a href="http://www.dis.uniroma1.it/challenge9/download.shtml">DIMACS challenge on Shortest Path problems</a>
show the pros and cons of each implementation. Three instances are generated using the <strong>rand</strong> graph generator, while 10 instances are
road networks. The test are done on my late 2008 MacBookPro using the apple gcc-4.2 compiler.
All the source code, scripts, and even this post text, are available on <a href="https://github.com/stegua/MyBlogEntries/tree/master/Dijkstra">github</a>.</p>

<h2 id="rand-graphs">RAND Graphs</h2>

<p>The first test compares the four implementations on 3 graphs with different density <em>d</em> that is the ratio <script type="math/tex">\frac{2m}{n(n-1)}</script>.
The graphs are:</p>

<ol>
  <li><strong>Rand 1</strong>: with <em>n</em>=10000, <em>m</em>=100000, <em>d</em>=0.001</li>
  <li><strong>Rand 2</strong>: with <em>n</em>=10000, <em>m</em>=1000000, <em>d</em>=0.01</li>
  <li><strong>Rand 3</strong>: with <em>n</em>=10000, <em>m</em>=10000000, <em>d</em>=0.1</li>
</ol>

<p>For each graph, 50 queries between different pairs of source and destination nodes are performed.
The table below reports the average of query times (total time divided by query numbers).
The entries in bold highlight the shortest time per row.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">Graph</th>
      <th style="text-align: center">MyGraph</th>
      <th style="text-align: center">BGL</th>
      <th style="text-align: center">Lemon</th>
      <th style="text-align: center">OrTools</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">Rand 1</td>
      <td style="text-align: center"><strong>0.0052</strong></td>
      <td style="text-align: center">0.0059</td>
      <td style="text-align: center">0.0074</td>
      <td style="text-align: center">1.2722</td>
    </tr>
    <tr>
      <td style="text-align: left">Rand 2</td>
      <td style="text-align: center"><strong>0.0134</strong></td>
      <td style="text-align: center">0.0535</td>
      <td style="text-align: center">0.0706</td>
      <td style="text-align: center">1.6128</td>
    </tr>
    <tr>
      <td style="text-align: left">Rand 3</td>
      <td style="text-align: center"><strong>0.0705</strong></td>
      <td style="text-align: center">0.5276</td>
      <td style="text-align: center">0.7247</td>
      <td style="text-align: center">4.2535</td>
    </tr>
  </tbody>
</table>

<p><br />
In these tests, it looks like my implementation is the winner… wow!
Although, the true winner is the boost::heap library, since the nasty implementation details
are delegated to that library.</p>

<p>… but come on! These are artificial graphs: who is really interested in shortest paths on random graphs?</p>

<h2 id="road-networks">Road Networks</h2>

<p>The second test uses road networks that are <strong>very</strong> sparse graphs. 
We report only average computation time in seconds over 50 different pair of source-destination nodes.
We decided to leave out OrTools since it is not very performing on very sparse graphs.</p>

<p>This table below shows the average query time for the standard implementations that use <strong>Fibonacci Heaps</strong>.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">Area</th>
      <th style="text-align: center">nodes</th>
      <th style="text-align: center">arcs</th>
      <th style="text-align: center">MyGraph</th>
      <th style="text-align: center">BGL</th>
      <th style="text-align: center">Lemon</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">Western USA</td>
      <td style="text-align: center">6,262,104</td>
      <td style="text-align: center">15,248,146</td>
      <td style="text-align: center"><strong>2.7215</strong></td>
      <td style="text-align: center">2.7804</td>
      <td style="text-align: center">3.8181</td>
    </tr>
    <tr>
      <td style="text-align: left">Eastern USA</td>
      <td style="text-align: center">3,598,623</td>
      <td style="text-align: center">8,778,114</td>
      <td style="text-align: center">1.9425</td>
      <td style="text-align: center"><strong>1.4255</strong></td>
      <td style="text-align: center">2.7147</td>
    </tr>
    <tr>
      <td style="text-align: left">Great Lakes</td>
      <td style="text-align: center">2,758,119</td>
      <td style="text-align: center">6,885,658</td>
      <td style="text-align: center"><strong>0.1808</strong></td>
      <td style="text-align: center">0.8946</td>
      <td style="text-align: center">0.2602</td>
    </tr>
    <tr>
      <td style="text-align: left">California and Nevada</td>
      <td style="text-align: center">1,890,815</td>
      <td style="text-align: center">4,657,742</td>
      <td style="text-align: center"><strong>0.5078</strong></td>
      <td style="text-align: center">0.5808</td>
      <td style="text-align: center">0.7083</td>
    </tr>
    <tr>
      <td style="text-align: left">Northeast USA</td>
      <td style="text-align: center">1,524,453</td>
      <td style="text-align: center">3,897,636</td>
      <td style="text-align: center">0.6061</td>
      <td style="text-align: center"><strong>0.5662</strong></td>
      <td style="text-align: center">0.8335</td>
    </tr>
    <tr>
      <td style="text-align: left">Northwest USA</td>
      <td style="text-align: center">1,207,945</td>
      <td style="text-align: center">2,840,208</td>
      <td style="text-align: center">0.3652</td>
      <td style="text-align: center"><strong>0.3506</strong></td>
      <td style="text-align: center">0.5152</td>
    </tr>
    <tr>
      <td style="text-align: left">Florida</td>
      <td style="text-align: center">1,070,376</td>
      <td style="text-align: center">2,712,798</td>
      <td style="text-align: center"><strong>0.1141</strong></td>
      <td style="text-align: center">0.2753</td>
      <td style="text-align: center">0.1574</td>
    </tr>
    <tr>
      <td style="text-align: left">Colorado</td>
      <td style="text-align: center">435,666</td>
      <td style="text-align: center">1,057,066</td>
      <td style="text-align: center">0.1423</td>
      <td style="text-align: center"><strong>0.1117</strong></td>
      <td style="text-align: center">0.1965</td>
    </tr>
    <tr>
      <td style="text-align: left">San Francisco Bay</td>
      <td style="text-align: center">321,270</td>
      <td style="text-align: center">800,172</td>
      <td style="text-align: center">0.1721</td>
      <td style="text-align: center"><strong>0.0836</strong></td>
      <td style="text-align: center">0.2399</td>
    </tr>
    <tr>
      <td style="text-align: left">New York City</td>
      <td style="text-align: center">264,346</td>
      <td style="text-align: center">733,846</td>
      <td style="text-align: center"><strong>0.0121</strong></td>
      <td style="text-align: center">0.0677</td>
      <td style="text-align: center">0.0176</td>
    </tr>
  </tbody>
</table>

<p><br />
From this table, BGL and my implementation are equally good, while Lemon comes after.
What would happen if we use a diffent type of heap?</p>

<p>This second table shows the average query time for the Lemon graph library with a specialized 
<a href="http://lemon.cs.elte.hu/pub/doc/latest/a00048.html">Binary Heap</a> implementation,
and my own implementation with generic <strong>2-Heap</strong> and <strong>3-Heap</strong> (binary and ternary heaps) and with a <strong>Skew Heap</strong>.
Note that in order to use a different heap I just modify a single line of code.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">Area</th>
      <th style="text-align: center">nodes</th>
      <th style="text-align: center">arcs</th>
      <th style="text-align: center">2-Heap</th>
      <th style="text-align: center">3-Heap</th>
      <th style="text-align: center">Skew Heap</th>
      <th style="text-align: center">Lemon 2-Heap</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">Western USA</td>
      <td style="text-align: center">6,262,104</td>
      <td style="text-align: center">15,248,146</td>
      <td style="text-align: center">1.977</td>
      <td style="text-align: center">1.934</td>
      <td style="text-align: center">2.104</td>
      <td style="text-align: center"><strong>1.359</strong></td>
    </tr>
    <tr>
      <td style="text-align: left">Eastern USA</td>
      <td style="text-align: center">3,598,623</td>
      <td style="text-align: center">8,778,114</td>
      <td style="text-align: center">1.406</td>
      <td style="text-align: center">1.372</td>
      <td style="text-align: center">1.492</td>
      <td style="text-align: center"><strong>0.938</strong></td>
    </tr>
    <tr>
      <td style="text-align: left">Great Lakes</td>
      <td style="text-align: center">2,758,119</td>
      <td style="text-align: center">6,885,658</td>
      <td style="text-align: center">0.132</td>
      <td style="text-align: center">0.130</td>
      <td style="text-align: center">0.135</td>
      <td style="text-align: center"><strong>0.109</strong></td>
    </tr>
    <tr>
      <td style="text-align: left">California and Nevada</td>
      <td style="text-align: center">1,890,815</td>
      <td style="text-align: center">4,657,742</td>
      <td style="text-align: center">0.361</td>
      <td style="text-align: center">0.353</td>
      <td style="text-align: center">0.372</td>
      <td style="text-align: center"><strong>0.241</strong></td>
    </tr>
    <tr>
      <td style="text-align: left">Northeast USA</td>
      <td style="text-align: center">1,524,453</td>
      <td style="text-align: center">3,897,636</td>
      <td style="text-align: center">0.433</td>
      <td style="text-align: center">0.421</td>
      <td style="text-align: center">0.457</td>
      <td style="text-align: center"><strong>0.287</strong></td>
    </tr>
    <tr>
      <td style="text-align: left">Northwest USA</td>
      <td style="text-align: center">1,207,945</td>
      <td style="text-align: center">2,840,208</td>
      <td style="text-align: center">0.257</td>
      <td style="text-align: center">0.252</td>
      <td style="text-align: center">0.256</td>
      <td style="text-align: center"><strong>0.166</strong></td>
    </tr>
    <tr>
      <td style="text-align: left">Florida</td>
      <td style="text-align: center">1,070,376</td>
      <td style="text-align: center">2,712,798</td>
      <td style="text-align: center">0.083</td>
      <td style="text-align: center">0.081</td>
      <td style="text-align: center">0.080</td>
      <td style="text-align: center"><strong>0.059</strong></td>
    </tr>
    <tr>
      <td style="text-align: left">Colorado</td>
      <td style="text-align: center">435,666</td>
      <td style="text-align: center">1,057,066</td>
      <td style="text-align: center">0.100</td>
      <td style="text-align: center">0.098</td>
      <td style="text-align: center">0.100</td>
      <td style="text-align: center"><strong>0.064</strong></td>
    </tr>
    <tr>
      <td style="text-align: left">San Francisco Bay</td>
      <td style="text-align: center">321,270</td>
      <td style="text-align: center">800,172</td>
      <td style="text-align: center">0.121</td>
      <td style="text-align: center">0.117</td>
      <td style="text-align: center">0.122</td>
      <td style="text-align: center"><strong>0.075</strong></td>
    </tr>
    <tr>
      <td style="text-align: left">New York City</td>
      <td style="text-align: center">264,346</td>
      <td style="text-align: center">733,846</td>
      <td style="text-align: center">0.009</td>
      <td style="text-align: center">0.009</td>
      <td style="text-align: center">0.009</td>
      <td style="text-align: center"><strong>0.007</strong></td>
    </tr>
  </tbody>
</table>

<p><br />
Mmmm… I am no longer the winner: COIN-OR Lemon is!</p>

<p>This is likely due to the specialized binary heap implementation of the Lemon library.
Instead, the boost::heap library has a <strong>d-ary-heap</strong>, that for <em>d=2</em> is a generic binary heap.</p>

<h2 id="so-what">So what?</h2>

<p>Dijkstra’s algorithm is so beatiful because it has the <em>elegance of simplicity</em>.</p>

<p>Using an existing efficient heap data structure, it is easy to implement an <strong>“efficient”</strong> version of the algorithm.</p>

<p>However, if you have spare time, or you need to solve shortest path problems on a specific type of graphs (e.g., road networks),
you might give a try with existing graph libraries, before investing developing time in your own implementation.
In addition, be sure to read [4] and the references therein contained.</p>

<p>All the code I have used to write this post is available on <a href="https://github.com/stegua/MyBlogEntries/tree/master/Dijkstra">github</a>. 
If you have any comment or criticism, do not hesitate to comment below.</p>

<h3 id="references">References</h3>

<ol>
  <li>
    <p> Pohl, I.
<span class="title">Bi-directional and heuristic search in path problems</span>. 
Department of Computer Science, Stanford University, 1969.
<a href="http://www.slac.stanford.edu/cgi-wrap/getdoc/slac-r-104.pdf">[pdf]</a></p>
  </li>
  <li>
    <p>Sniedovich, M.
<span class="title">Dijkstra&#8217;s algorithm revisited: the dynamic programming connexion</span>.
<span class="journal">Control and cybernetics</span> vol. 35(3), pages 599-620, 2006.
<a href="http://oxygene.ibspan.waw.pl:3000/contents/export?filename=Sniedovich.pdf">[pdf]</a></p>
  </li>
  <li>
    <p>Dantzig, G.B.
<span class="title">Linear Programming and Extensions</span>.
Princeton University Press, Princeton, NJ, 1962.</p>
  </li>
  <li>
    <p>Delling, D. and Sanders, P. and Schultes, D. and Wagner, D.
<span class="title">Engineering route planning algorithms</span>.
<span class="journal">Algorithmics of large and complex networks</span>
Lecture Notes in Computer Science, Volume 5515, pages 117-139, 2009.
<a href="http://dx.doi.org/10.1007/978-3-642-02094-0_7">[doi]</a></p>
  </li>
  <li>
    <p>Goldberg, A.V. and Harrelson, C.
<span class="title">Computing the shortest path: A-star search meets graph theory</span>.
<span class="journal">Proc. of the sixteenth annual ACM-SIAM symposium on Discrete algorithms</span>, 156-165, 2005.
<a href="http://research.microsoft.com/apps/pubs/default.aspx?id=64511">[pdf]</a></p>
  </li>
</ol>

]]></content>
  </entry>
  
</feed>
